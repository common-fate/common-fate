/**
 * Generated by orval v6.11.1 üç∫
 * Do not edit manually.
 * Example API
 * Example API
 * OpenAPI spec version: 1.0
 */
import useSwr from 'swr'
import type {
  SWRConfiguration,
  Key
} from 'swr'
import { customInstanceRegistry } from '../custom-instance';
import type { ErrorType } from '../custom-instance';
export type RegisterProvidersResponseResponse = {
  zipUploadUrl: string;
};

export type ListProvidersResponseResponse = {
  providers: Provider[];
  next: string | null;
};

export type ErrorResponseResponse = {
  error?: string;
};

export type HealthResponseResponse = {
  healthy: boolean;
};

/**
 * The log level.
 */
export type ProviderSetupDiagnosticLogLevel = typeof ProviderSetupDiagnosticLogLevel[keyof typeof ProviderSetupDiagnosticLogLevel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProviderSetupDiagnosticLogLevel = {
  INFO: 'INFO',
  WARNING: 'WARNING',
  ERROR: 'ERROR',
} as const;

/**
 * A log entry related to a provider setup validation.
 */
export interface ProviderSetupDiagnosticLog {
  /** The log level. */
  level: ProviderSetupDiagnosticLogLevel;
  /** The log message. */
  msg: string;
}

/**
 * The status of the validation.
 */
export type ProviderSetupValidationStatus = typeof ProviderSetupValidationStatus[keyof typeof ProviderSetupValidationStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProviderSetupValidationStatus = {
  IN_PROGRESS: 'IN_PROGRESS',
  SUCCESS: 'SUCCESS',
  PENDING: 'PENDING',
  ERROR: 'ERROR',
} as const;

/**
 * A validation against the configuration values of the Access Provider.
 */
export interface ProviderSetupValidation {
  /** The ID of the validation, such as `list-sso-users`. */
  id: string;
  /** The status of the validation. */
  status: ProviderSetupValidationStatus;
  /** The particular config fields validated, if any. */
  fieldsValidated: unknown[];
  logs?: ProviderSetupDiagnosticLog[];
}

export interface ProviderConfigValue {
  /** The ID of the config field. */
  id: string;
  /** The value entered by the user. */
  value: string;
}

export interface ProviderConfigField {
  id: string;
  name: string;
  description: string;
  /** Whether the config value is optional. */
  isOptional: boolean;
  /** Whether or not the config field is a secret (like an API key or a password) */
  isSecret: boolean;
  /** the path to where the secret will be stored, in a secrets manager like AWS SSM Parameter Store. */
  secretPath?: string;
}

export interface ProviderSetupStepDetails {
  title: string;
  instructions: string;
  configFields: ProviderConfigField[];
}

/**
 * Indicates whether a setup step is complete or not.
 */
export interface ProviderSetupStepOverview {
  /** Whether the step has been completed. */
  complete: boolean;
}

export interface ProviderSetupInstructions {
  stepDetails: ProviderSetupStepDetails[];
}

export interface ResourceLoader {
  title: string;
}

export type AuditSchemaResourceLoaders = {[key: string]: ResourceLoader};

export interface AuditSchema {
  resourceLoaders: AuditSchemaResourceLoaders;
}

export interface ConfigurationSchema {[key: string]: ConfigurationArgument}

export interface TargetSchema {[key: string]: TargetArgument}

export interface ProviderSchema {
  schemaVersion: string;
  providerVersion: string;
  configuration: ConfigurationSchema;
  audit: AuditSchema;
  target: TargetSchema;
}

/**
 * An argument group
 */
export interface TargetArgumentGroup {
  id: string;
  title: string;
  description?: string;
}

export type TargetArgumentGroups = {[key: string]: TargetArgumentGroup};

/**
 * Optional form element for the request form, if not provided, defaults to multiselect
 */
export type TargetArgumentRequestFormElement = typeof TargetArgumentRequestFormElement[keyof typeof TargetArgumentRequestFormElement];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TargetArgumentRequestFormElement = {
  SELECT: 'SELECT',
} as const;

export type TargetArgumentRuleFormElement = typeof TargetArgumentRuleFormElement[keyof typeof TargetArgumentRuleFormElement];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TargetArgumentRuleFormElement = {
  INPUT: 'INPUT',
  MULTISELECT: 'MULTISELECT',
  SELECT: 'SELECT',
} as const;

/**
 * Define the metadata, data type and UI elements for the argument
 */
export interface TargetArgument {
  id: string;
  title: string;
  description?: string;
  ruleFormElement: TargetArgumentRuleFormElement;
  /** Optional form element for the request form, if not provided, defaults to multiselect */
  requestFormElement: TargetArgumentRequestFormElement;
  groups: TargetArgumentGroups;
}

export type ConfigurationArgumentType = typeof ConfigurationArgumentType[keyof typeof ConfigurationArgumentType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConfigurationArgumentType = {
  STRING: 'STRING',
  SECRETSTRING: 'SECRETSTRING',
} as const;

export interface ConfigurationArgument {
  id: string;
  type: ConfigurationArgumentType;
  secret: boolean;
  optional: boolean;
  usage: string;
  name: string;
}

export interface S3Asset {
  path: string;
  bucket: string;
  region: string;
}

export interface Usage {
  usage: string;
}

export type SetupSchema = {[key: string]: ConfigurationArgument};

export interface Setup {
  steps: string[];
  schema: SetupSchema;
}

/**
 * A registered provider version
 */
export interface Provider {
  team: string;
  name: string;
  version: string;
  lambdaAssetS3Arn: string;
  schema: ProviderSchema;
}




  
  // eslint-disable-next-line
  type SecondParameter<T extends (...args: any) => any> = T extends (
  config: any,
  args: infer P,
) => any
  ? P
  : never;

/**
 * Returns the health of the service. If any healthchecks fail the response code will be 500 (Internal Server Error).
 * @summary Healthcheck
 */
export const getHealth = (
    
 options?: SecondParameter<typeof customInstanceRegistry>) => {
      return customInstanceRegistry<HealthResponseResponse>(
      {url: `/api/v1/health`, method: 'get'
    },
      options);
    }
  

export const getGetHealthKey = () => [`/api/v1/health`];

    
export type GetHealthQueryResult = NonNullable<Awaited<ReturnType<typeof getHealth>>>
export type GetHealthQueryError = ErrorType<unknown>

export const useGetHealth = <TError = ErrorType<unknown>>(
  options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getHealth>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstanceRegistry> }

  ) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
    const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetHealthKey() : null);
  const swrFn = () => getHealth(requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}


/**
 * @summary Get Provider
 */
export const getProvider = (
    team: string,
    name: string,
    version: string,
 options?: SecondParameter<typeof customInstanceRegistry>) => {
      return customInstanceRegistry<Provider>(
      {url: `/api/v1/team/${team}/providers/${name}/${version}`, method: 'get'
    },
      options);
    }
  

export const getGetProviderKey = (team: string,
    name: string,
    version: string,) => [`/api/v1/team/${team}/providers/${name}/${version}`];

    
export type GetProviderQueryResult = NonNullable<Awaited<ReturnType<typeof getProvider>>>
export type GetProviderQueryError = ErrorType<unknown>

export const useGetProvider = <TError = ErrorType<unknown>>(
 team: string,
    name: string,
    version: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getProvider>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstanceRegistry> }

  ) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(team && name && version)
    const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetProviderKey(team,name,version) : null);
  const swrFn = () => getProvider(team,name,version, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}


/**
 * @summary Get Provider Setup Docs
 */
export const getProviderSetupDocs = (
    team: string,
    name: string,
    version: string,
 options?: SecondParameter<typeof customInstanceRegistry>) => {
      return customInstanceRegistry<string[]>(
      {url: `/api/v1/team/${team}/providers/${name}/${version}/setup`, method: 'get'
    },
      options);
    }
  

export const getGetProviderSetupDocsKey = (team: string,
    name: string,
    version: string,) => [`/api/v1/team/${team}/providers/${name}/${version}/setup`];

    
export type GetProviderSetupDocsQueryResult = NonNullable<Awaited<ReturnType<typeof getProviderSetupDocs>>>
export type GetProviderSetupDocsQueryError = ErrorType<unknown>

export const useGetProviderSetupDocs = <TError = ErrorType<unknown>>(
 team: string,
    name: string,
    version: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getProviderSetupDocs>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstanceRegistry> }

  ) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(team && name && version)
    const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetProviderSetupDocsKey(team,name,version) : null);
  const swrFn = () => getProviderSetupDocs(team,name,version, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}


/**
 * @summary Get Provider Usage Doc
 */
export const getProviderUsageDoc = (
    team: string,
    name: string,
    version: string,
 options?: SecondParameter<typeof customInstanceRegistry>) => {
      return customInstanceRegistry<string[]>(
      {url: `/api/v1/team/${team}/providers/${name}/${version}/usage`, method: 'get'
    },
      options);
    }
  

export const getGetProviderUsageDocKey = (team: string,
    name: string,
    version: string,) => [`/api/v1/team/${team}/providers/${name}/${version}/usage`];

    
export type GetProviderUsageDocQueryResult = NonNullable<Awaited<ReturnType<typeof getProviderUsageDoc>>>
export type GetProviderUsageDocQueryError = ErrorType<unknown>

export const useGetProviderUsageDoc = <TError = ErrorType<unknown>>(
 team: string,
    name: string,
    version: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getProviderUsageDoc>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstanceRegistry> }

  ) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(team && name && version)
    const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetProviderUsageDocKey(team,name,version) : null);
  const swrFn = () => getProviderUsageDoc(team,name,version, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}


/**
 * @summary List Providers
 */
export const listAllProviders = (
    
 options?: SecondParameter<typeof customInstanceRegistry>) => {
      return customInstanceRegistry<ListProvidersResponseResponse>(
      {url: `/api/v1/providers`, method: 'get'
    },
      options);
    }
  

export const getListAllProvidersKey = () => [`/api/v1/providers`];

    
export type ListAllProvidersQueryResult = NonNullable<Awaited<ReturnType<typeof listAllProviders>>>
export type ListAllProvidersQueryError = ErrorType<ErrorResponseResponse>

export const useListAllProviders = <TError = ErrorType<ErrorResponseResponse>>(
  options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listAllProviders>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstanceRegistry> }

  ) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
    const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListAllProvidersKey() : null);
  const swrFn = () => listAllProviders(requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}


