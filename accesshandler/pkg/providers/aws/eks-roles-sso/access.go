package eksrolessso

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/iam"
	iamtypes "github.com/aws/aws-sdk-go-v2/service/iam/types"
	"github.com/aws/aws-sdk-go-v2/service/identitystore"
	idtypes "github.com/aws/aws-sdk-go-v2/service/identitystore/types"
	"github.com/aws/aws-sdk-go-v2/service/ssoadmin"
	"github.com/aws/aws-sdk-go-v2/service/ssoadmin/types"
	"github.com/common-fate/granted-approvals/pkg/cfaws/policy"
	"github.com/pkg/errors"
	"github.com/sethvargo/go-retry"
	v1 "k8s.io/api/rbac/v1"
	v1meta "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type Args struct {
	Role string `json:"role" jsonschema:"title=Role"`
}

func (p *Provider) Grant(ctx context.Context, subject string, args []byte, grantID string) error {
	var a Args
	err := json.Unmarshal(args, &a)
	if err != nil {
		return err
	}
	// how will we track all the items that we have created?
	// We only ever need to create a single copy of the iam policy using a create or update operation
	// The permission set is created per user and needs to be deleted afterwards, so how do we track this state, naming convention?
	//
	key := fmt.Sprintf("granted-approvals-%s", grantID)

	// @TODO work out what aws permissions are actually required for cluster access
	eksPolicyDocument := policy.Policy{
		Version: "2012-10-17",
		Statements: []policy.Statement{
			{
				Effect: "Allow",
				Action: []string{
					"eks:*",
				},
				Resource: []string{"*"},
			},
		},
	}

	// create permission set with policy
	permSet, err := p.ssoClient.CreatePermissionSet(ctx, &ssoadmin.CreatePermissionSetInput{
		InstanceArn: aws.String(p.instanceARN.Get()),
		Name:        aws.String(key),
		Description: aws.String("This permission set was automatically generated by Granted Approvals"),
	})
	if err != nil {
		return err
	}
	// Assign eks policy to permission set
	_, err = p.ssoClient.PutInlinePolicyToPermissionSet(ctx, &ssoadmin.PutInlinePolicyToPermissionSetInput{
		InlinePolicy:     aws.String(eksPolicyDocument.String()),
		InstanceArn:      aws.String(p.instanceARN.Get()),
		PermissionSetArn: permSet.PermissionSet.PermissionSetArn,
	})
	if err != nil {
		return err
	}

	// assign user to permission set

	// find the user ID from the provided email address.
	user, err := p.getUser(ctx, subject)
	if err != nil {
		return err
	}

	res, err := p.ssoClient.CreateAccountAssignment(ctx, &ssoadmin.CreateAccountAssignmentInput{
		InstanceArn:      aws.String(p.instanceARN.Get()),
		PermissionSetArn: permSet.PermissionSet.PermissionSetArn,
		PrincipalType:    types.PrincipalTypeUser,
		PrincipalId:      user.UserId,
		TargetId:         &p.awsAccountID,
		TargetType:       types.TargetTypeAwsAccount,
	})
	if err != nil {
		return err
	}

	if res.AccountAssignmentCreationStatus.FailureReason != nil {
		return fmt.Errorf("failed creating account assignment: %s", *res.AccountAssignmentCreationStatus.FailureReason)
	}
	role, err := p.GetIAMRoleForPermissionSetWithRetry(ctx, key)
	if err != nil {
		return err
	}
	_ = role

	// create a kubernetes role-binding for subject to the kubernetes role

	rb := v1.RoleBinding{
		TypeMeta: v1meta.TypeMeta{Kind: "RoleBinding", APIVersion: "rbac.authorization.k8s.io/v1"},
		// use the key for the name
		ObjectMeta: v1meta.ObjectMeta{Name: key},
		// use the key as the user too
		Subjects: []v1.Subject{{Kind: "User", APIGroup: "rbac.authorization.k8s.io", Name: key, Namespace: p.namespace.Get()}},
		RoleRef:  v1.RoleRef{APIGroup: "rbac.authorization.k8s.io", Kind: "Role", Name: a.Role},
	}
	r, err := p.kubeClient.RbacV1().RoleBindings(p.clusterName.Get()).Create(ctx, &rb, v1meta.CreateOptions{})
	if err != nil {
		return err
	}
	_ = r
	// create a role map entry for the iam role of the permission set to the kubernetes user in the aws-auth config map
	awsAuth, err := p.kubeClient.CoreV1().ConfigMaps("kube-system").Get(ctx, "aws-auth", v1meta.GetOptions{})
	if err != nil {
		return err
	}

	_ = awsAuth
	// p.kubeClient.RbacV1().RoleBindings(p.clusterName.Get()).Delete(ctx, "", v1meta.DeleteOptions{})
	return nil
}

func (p *Provider) GetIAMRoleForPermissionSetWithRetry(ctx context.Context, permissionSetName string) (*iamtypes.Role, error) {
	var roleOutput *iamtypes.Role
	b := retry.NewFibonacci(time.Second)
	b = retry.WithMaxDuration(time.Second*60, b)
	err := retry.Do(ctx, b, func(ctx context.Context) (err error) {
		var marker *string
		hasMore := true
		roleNamePrefix := "/AWSReservedSSO_" + permissionSetName
		for hasMore {
			listRolesResponse, err := p.iamClient.ListRoles(ctx, &iam.ListRolesInput{PathPrefix: aws.String(roleNamePrefix), Marker: marker})
			if err != nil {
				return err
			}
			marker = listRolesResponse.Marker
			hasMore = listRolesResponse.IsTruncated
			for _, role := range listRolesResponse.Roles {
				if strings.HasPrefix(aws.ToString(role.RoleName), roleNamePrefix) {
					r := role
					roleOutput = &r
				}
			}
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	if roleOutput == nil {
		return nil, errors.New("role not found after assiging permission set")
	}

	return roleOutput, nil
}

// getUser retrieves the AWS SSO user from a provided email address.
func (p *Provider) getUser(ctx context.Context, email string) (*idtypes.User, error) {
	res, err := p.idStoreClient.ListUsers(ctx, &identitystore.ListUsersInput{
		IdentityStoreId: aws.String(p.identityStoreID.Get()),
		Filters: []idtypes.Filter{{
			AttributePath:  aws.String("UserName"),
			AttributeValue: aws.String(email),
		}},
	})
	if err != nil {
		return nil, err
	}
	if len(res.Users) == 0 {
		return nil, &UserNotFoundError{Email: email}
	}
	if len(res.Users) > 1 {
		// this should never happen, but check it anyway.
		return nil, fmt.Errorf("expected 1 user but found %v", len(res.Users))
	}

	return &res.Users[0], nil
}
func (p *Provider) Revoke(ctx context.Context, subject string, args []byte, grantID string) error {
	var a Args
	err := json.Unmarshal(args, &a)
	if err != nil {
		return err
	}

	// reverse the process from grant step

	return err
}

func (p *Provider) IsActive(ctx context.Context, subject string, args []byte, grantID string) (bool, error) {
	var a Args
	err := json.Unmarshal(args, &a)
	if err != nil {
		return false, err
	}

	// we didn't find the user, so return false.
	return false, nil
}

// func (p *Provider) Instructions(ctx context.Context, subject string, args []byte) (string, error) {
// 	return "", nil
// }
// func (p *Provider) upsertPermissionBoundaryPolicy(ctx context.Context) (string, error) {
// 	permissionBoundaryPolicyDocument := policy.Policy{
// 		Version: "2012-10-17",
// 		Statements: []policy.Statement{
// 			{
// 				Effect: "Allow",
// 				NotAction: []string{
// 					"iam:*",
// 					"organizations:*",
// 					"account:*",
// 				},
// 				Resource: []string{"*"},
// 			},
// 			{
// 				Effect: "Allow",
// 				Action: []string{
// 					"iam:Get*",
// 					"iam:List*",
// 					"iam:Generate*",
// 					"iam:Simulate*",
// 					"iam:CreateServiceLinkedRole",
// 					"iam:DeleteServiceLinkedRole",
// 					"organizations:List*",
// 					"organizations:Describe*",
// 					"account:List*",
// 					"account:Get*",
// 				},
// 				Resource: []string{"*"},
// 			},
// 		},
// 	}
// 	permissionBoundaryPolicyName := "GrantedApprovalsPermissionBoundaryDenyIAM"

// 	// Define the ARN for the permission boundary policy
// 	permissionBoundaryPolicyARN := fmt.Sprintf("arn:aws:iam::%s:policy/%s", p.awsAccountID, permissionBoundaryPolicyName)
// 	existinPpermissionBoundaryPolicy, err := p.iamClient.GetPolicy(ctx, &iam.GetPolicyInput{
// 		PolicyArn: &permissionBoundaryPolicyARN,
// 	})

// 	if err != nil {
// 		// check if the error is a NoSuchEntityException - if it is, the Permission Boundary doesn't exist
// 		var rnf *iamtypes.NoSuchEntityException
// 		if errors.As(err, &rnf) {
// 			_, err = p.iamClient.CreatePolicy(ctx, &iam.CreatePolicyInput{
// 				PolicyName:     &permissionBoundaryPolicyName,
// 				PolicyDocument: aws.String(permissionBoundaryPolicyDocument.String()),
// 				Tags: []iamtypes.Tag{
// 					{
// 						Key:   aws.String("granted-approvals/managed"),
// 						Value: aws.String("true"),
// 					},
// 				},
// 			})
// 			if err != nil {
// 				return "", err
// 			}
// 		} else {
// 			// if the error isn't NoSuchEntityException, something else went wrong, so stop what we're doing
// 			// and return the error to the caller.
// 			return "", err
// 		}
// 	} else {
// 		// If the policy does exist, check it matches what we expect
// 		// Get the default policy version
// 		pv, err := p.iamClient.GetPolicyVersion(ctx, &iam.GetPolicyVersionInput{
// 			PolicyArn: &permissionBoundaryPolicyARN,
// 			VersionId: existinPpermissionBoundaryPolicy.Policy.DefaultVersionId,
// 		})
// 		if err != nil {
// 			return "", err
// 		}

// 		// Decode the RFC3986 url

// 		decodedValue, err := url.QueryUnescape(*pv.PolicyVersion.Document)
// 		if err != nil {
// 			return "", err
// 		}
// 		// Check if the policy matches what we expect
// 		if permissionBoundaryPolicyDocument.String() != decodedValue {
// 			// If the policy does not match, create a new policy version and set this as the default
// 			// First we need to delete old versions of the policy so we do not run into an error creating too many versions
// 			// First, check how many policy versions we have
// 			v, err := p.iamClient.ListPolicyVersions(ctx, &iam.ListPolicyVersionsInput{
// 				PolicyArn: &permissionBoundaryPolicyARN,
// 			})
// 			if err != nil {
// 				return "", err
// 			}
// 			if len(v.Versions) == 5 {
// 				// We have too many existing policy versions and need to delete the oldest
// 				last := v.Versions[4]
// 				// Ensure we aren't deleting the default version
// 				if last.IsDefaultVersion {
// 					last = v.Versions[3]
// 				}
// 				_, err = p.iamClient.DeletePolicyVersion(ctx, &iam.DeletePolicyVersionInput{
// 					PolicyArn: &permissionBoundaryPolicyARN,
// 					VersionId: last.VersionId,
// 				})
// 				if err != nil {
// 					return "", err
// 				}
// 			}
// 			_, err = p.iamClient.CreatePolicyVersion(ctx, &iam.CreatePolicyVersionInput{
// 				PolicyArn:      &permissionBoundaryPolicyARN,
// 				PolicyDocument: aws.String(permissionBoundaryPolicyDocument.String()),
// 				SetAsDefault:   true,
// 			})
// 			if err != nil {
// 				return "", err
// 			}
// 		}
// 	}

// 	return permissionBoundaryPolicyName, nil
// }
