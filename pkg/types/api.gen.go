// Package types provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package types

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	externalRef0 "github.com/common-fate/granted-approvals/accesshandler/pkg/types"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// Defines values for AccessRuleStatus.
const (
	AccessRuleStatusACTIVE   AccessRuleStatus = "ACTIVE"
	AccessRuleStatusARCHIVED AccessRuleStatus = "ARCHIVED"
)

// Defines values for AccessRuleTargetDetailArgumentsFormElement.
const (
	INPUT       AccessRuleTargetDetailArgumentsFormElement = "INPUT"
	MULTISELECT AccessRuleTargetDetailArgumentsFormElement = "MULTISELECT"
)

// Defines values for ApprovalMethod.
const (
	AUTOMATIC ApprovalMethod = "AUTOMATIC"
	REVIEWED  ApprovalMethod = "REVIEWED"
)

// Defines values for GrantStatus.
const (
	GrantStatusACTIVE  GrantStatus = "ACTIVE"
	GrantStatusERROR   GrantStatus = "ERROR"
	GrantStatusEXPIRED GrantStatus = "EXPIRED"
	GrantStatusPENDING GrantStatus = "PENDING"
	GrantStatusREVOKED GrantStatus = "REVOKED"
)

// Defines values for IdpStatus.
const (
	IdpStatusACTIVE   IdpStatus = "ACTIVE"
	IdpStatusARCHIVED IdpStatus = "ARCHIVED"
)

// Defines values for ProviderSetupStatus.
const (
	COMPLETE                       ProviderSetupStatus = "COMPLETE"
	INITIALCONFIGURATIONINPROGRESS ProviderSetupStatus = "INITIAL_CONFIGURATION_IN_PROGRESS"
	VALIDATING                     ProviderSetupStatus = "VALIDATING"
	VALIDATIONFAILED               ProviderSetupStatus = "VALIDATION_FAILED"
	VALIDATIONSUCEEDED             ProviderSetupStatus = "VALIDATION_SUCEEDED"
)

// Defines values for ProviderSetupDiagnosticLogLevel.
const (
	ProviderSetupDiagnosticLogLevelERROR   ProviderSetupDiagnosticLogLevel = "ERROR"
	ProviderSetupDiagnosticLogLevelINFO    ProviderSetupDiagnosticLogLevel = "INFO"
	ProviderSetupDiagnosticLogLevelWARNING ProviderSetupDiagnosticLogLevel = "WARNING"
)

// Defines values for ProviderSetupValidationStatus.
const (
	ProviderSetupValidationStatusERROR      ProviderSetupValidationStatus = "ERROR"
	ProviderSetupValidationStatusINPROGRESS ProviderSetupValidationStatus = "IN_PROGRESS"
	ProviderSetupValidationStatusPENDING    ProviderSetupValidationStatus = "PENDING"
	ProviderSetupValidationStatusSUCCESS    ProviderSetupValidationStatus = "SUCCESS"
)

// Defines values for RequestEventFromGrantStatus.
const (
	RequestEventFromGrantStatusACTIVE  RequestEventFromGrantStatus = "ACTIVE"
	RequestEventFromGrantStatusERROR   RequestEventFromGrantStatus = "ERROR"
	RequestEventFromGrantStatusEXPIRED RequestEventFromGrantStatus = "EXPIRED"
	RequestEventFromGrantStatusPENDING RequestEventFromGrantStatus = "PENDING"
	RequestEventFromGrantStatusREVOKED RequestEventFromGrantStatus = "REVOKED"
)

// Defines values for RequestEventToGrantStatus.
const (
	RequestEventToGrantStatusACTIVE  RequestEventToGrantStatus = "ACTIVE"
	RequestEventToGrantStatusERROR   RequestEventToGrantStatus = "ERROR"
	RequestEventToGrantStatusEXPIRED RequestEventToGrantStatus = "EXPIRED"
	RequestEventToGrantStatusPENDING RequestEventToGrantStatus = "PENDING"
	RequestEventToGrantStatusREVOKED RequestEventToGrantStatus = "REVOKED"
)

// Defines values for RequestStatus.
const (
	RequestStatusAPPROVED  RequestStatus = "APPROVED"
	RequestStatusCANCELLED RequestStatus = "CANCELLED"
	RequestStatusDECLINED  RequestStatus = "DECLINED"
	RequestStatusPENDING   RequestStatus = "PENDING"
)

// Defines values for ReviewDecision.
const (
	APPROVED ReviewDecision = "APPROVED"
	DECLINED ReviewDecision = "DECLINED"
)

// Access Rule contains information for an end user to make a request for access.
type AccessRule struct {
	Description string `json:"description"`
	ID          string `json:"id"`
	IsCurrent   bool   `json:"isCurrent"`
	Name        string `json:"name"`

	// A target for an access rule
	Target AccessRuleTarget `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`

	// A unique version identifier for the Access Rule. Updating a rule creates a new version.
	// When a rule is updated, it's ID remains consistent.
	Version string `json:"version"`
}

// AccessRuleDetail contains detailed information about a rule and is used in administrative apis.
type AccessRuleDetail struct {
	// Approver config for access rules
	Approval    ApproverConfig `json:"approval"`
	Description string         `json:"description"`

	// The group IDs that the access rule applies to.
	Groups    []string           `json:"groups"`
	ID        string             `json:"id"`
	IsCurrent bool               `json:"isCurrent"`
	Metadata  AccessRuleMetadata `json:"metadata"`
	Name      string             `json:"name"`

	// The status of an Access Rule.
	Status AccessRuleStatus `json:"status"`

	// A detailed target for an access rule
	Target AccessRuleTargetDetail `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`

	// A unique version identifier for the Access Rule. Updating a rule creates a new version.
	// When a rule is updated, it's ID remains consistent.
	Version string `json:"version"`
}

// AccessRuleMetadata defines model for AccessRuleMetadata.
type AccessRuleMetadata struct {
	CreatedAt     time.Time `json:"createdAt"`
	CreatedBy     string    `json:"createdBy"`
	UpdateMessage *string   `json:"updateMessage,omitempty"`
	UpdatedAt     time.Time `json:"updatedAt"`
	UpdatedBy     string    `json:"updatedBy"`
}

// The status of an Access Rule.
type AccessRuleStatus string

// A target for an access rule
type AccessRuleTarget struct {
	// Provider
	Provider Provider `json:"provider"`
}

// A detailed target for an access rule
type AccessRuleTargetDetail struct {
	// Provider
	Provider Provider                    `json:"provider"`
	With     AccessRuleTargetDetail_With `json:"with"`
}

// AccessRuleTargetDetail_With defines model for AccessRuleTargetDetail.With.
type AccessRuleTargetDetail_With struct {
	AdditionalProperties map[string]AccessRuleTargetDetailArguments `json:"-"`
}

// AccessRuleTargetDetailArguments defines model for AccessRuleTargetDetailArguments.
type AccessRuleTargetDetailArguments struct {
	FormElement AccessRuleTargetDetailArgumentsFormElement `json:"formElement"`
	Groupings   AccessRuleTargetDetailArguments_Groupings  `json:"groupings"`
	Values      []string                                   `json:"values"`
}

// AccessRuleTargetDetailArgumentsFormElement defines model for AccessRuleTargetDetailArguments.FormElement.
type AccessRuleTargetDetailArgumentsFormElement string

// AccessRuleTargetDetailArguments_Groupings defines model for AccessRuleTargetDetailArguments.Groupings.
type AccessRuleTargetDetailArguments_Groupings struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// AccessToken defines model for AccessToken.
type AccessToken = string

// Describes whether a request has been approved automatically or from a review
type ApprovalMethod string

// Approver config for access rules
type ApproverConfig struct {
	Groups []string `json:"groups"`

	// The user IDs of the approvers for the request.
	Users []string `json:"users"`
}

// a request body for creating a Access Rule Target
type CreateAccessRuleTarget struct {
	ProviderId string                      `json:"providerId"`
	With       CreateAccessRuleTarget_With `json:"with"`
}

// CreateAccessRuleTarget_With defines model for CreateAccessRuleTarget.With.
type CreateAccessRuleTarget_With struct {
	AdditionalProperties map[string]CreateAccessRuleTargetDetailArguments `json:"-"`
}

// CreateAccessRuleTargetDetailArguments defines model for CreateAccessRuleTargetDetailArguments.
type CreateAccessRuleTargetDetailArguments struct {
	Groupings CreateAccessRuleTargetDetailArguments_Groupings `json:"groupings"`
	Values    []string                                        `json:"values"`
}

// CreateAccessRuleTargetDetailArguments_Groupings defines model for CreateAccessRuleTargetDetailArguments.Groupings.
type CreateAccessRuleTargetDetailArguments_Groupings struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// CreateRequestWith defines model for CreateRequestWith.
type CreateRequestWith struct {
	AdditionalProperties map[string]string `json:"-"`
}

// A temporary assignment of a user to a principal.
type Grant struct {
	// The end time of the grant.
	End time.Time `json:"end"`

	// The ID of the provider to grant access to.
	Provider string `json:"provider"`

	// The start time of the grant.
	Start time.Time `json:"start"`

	// The current state of the grant.
	Status GrantStatus `json:"status"`

	// The email address of the user to grant access to.
	Subject openapi_types.Email `json:"subject"`
}

// The current state of the grant.
type GrantStatus string

// Group defines model for Group.
type Group struct {
	Description string   `json:"description"`
	Id          string   `json:"id"`
	MemberCount int      `json:"memberCount"`
	Members     []string `json:"members"`
	Name        string   `json:"name"`
	Source      string   `json:"source"`
}

// IdpStatus defines model for IdpStatus.
type IdpStatus string

// KeyValue defines model for KeyValue.
type KeyValue struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// A matched access rule with option values if they are required for the access rule request
type LookupAccessRule struct {
	// Access Rule contains information for an end user to make a request for access.
	AccessRule AccessRule `json:"accessRule"`

	// If the matched access rule has selectable fields, this array will contain the matched values to be used to prefill the form when requesting
	SelectableWithOptionValues *[]KeyValue `json:"selectableWithOptionValues,omitempty"`
}

// Provider
type Provider struct {
	Id   string `json:"id"`
	Type string `json:"type"`
}

// ProviderConfigField defines model for ProviderConfigField.
type ProviderConfigField struct {
	Description string `json:"description"`
	Id          string `json:"id"`

	// Whether the config value is optional.
	IsOptional bool `json:"isOptional"`

	// Whether or not the config field is a secret (like an API key or a password)
	IsSecret bool   `json:"isSecret"`
	Name     string `json:"name"`

	// the path to where the secret will be stored, in a secrets manager like AWS SSM Parameter Store.
	SecretPath *string `json:"secretPath,omitempty"`
}

// ProviderConfigValue defines model for ProviderConfigValue.
type ProviderConfigValue struct {
	// The ID of the config field.
	Id string `json:"id"`

	// The value entered by the user.
	Value string `json:"value"`
}

// A provider in the process of being set up through the guided setup workflow in Granted. These providers are **not** yet active.
type ProviderSetup struct {
	ConfigValidation []externalRef0.ProviderConfigValidation `json:"configValidation"`

	// The current configuration values.
	ConfigValues map[string]string `json:"configValues"`

	// A unique ID for the provider setup. This is a random KSUID to avoid potential conflicts with user-specified provider IDs in the `granted-deployment.yml` file.
	Id string `json:"id"`

	// The status of the setup process.
	Status ProviderSetupStatus `json:"status"`

	// An overview of the steps indicating whether they are complete.
	Steps []ProviderSetupStepOverview `json:"steps"`

	// The type of the Access Provider being set up.
	Type string `json:"type"`

	// The version of the provider.
	Version string `json:"version"`
}

// The status of the setup process.
type ProviderSetupStatus string

// A log entry related to a provider setup validation.
type ProviderSetupDiagnosticLog struct {
	// The log level.
	Level ProviderSetupDiagnosticLogLevel `json:"level"`

	// The log message.
	Msg string `json:"msg"`
}

// The log level.
type ProviderSetupDiagnosticLogLevel string

// ProviderSetupInstructions defines model for ProviderSetupInstructions.
type ProviderSetupInstructions struct {
	StepDetails []ProviderSetupStepDetails `json:"stepDetails"`
}

// ProviderSetupStepDetails defines model for ProviderSetupStepDetails.
type ProviderSetupStepDetails struct {
	ConfigFields []ProviderConfigField `json:"configFields"`
	Instructions string                `json:"instructions"`
	Title        string                `json:"title"`
}

// Indicates whether a setup step is complete or not.
type ProviderSetupStepOverview struct {
	// Whether the step has been completed.
	Complete bool `json:"complete"`
}

// A validation against the configuration values of the Access Provider.
type ProviderSetupValidation struct {
	// The particular config fields validated, if any.
	FieldsValidated []interface{} `json:"fieldsValidated"`

	// The ID of the validation, such as `list-sso-users`.
	Id   string                        `json:"id"`
	Logs *[]ProviderSetupDiagnosticLog `json:"logs,omitempty"`

	// The status of the validation.
	Status ProviderSetupValidationStatus `json:"status"`
}

// The status of the validation.
type ProviderSetupValidationStatus string

// A request to access something made by an end user in Granted.
type Request struct {
	AccessRuleId      string `json:"accessRuleId"`
	AccessRuleVersion string `json:"accessRuleVersion"`

	// Describes whether a request has been approved automatically or from a review
	ApprovalMethod *ApprovalMethod `json:"approvalMethod,omitempty"`

	// A temporary assignment of a user to a principal.
	Grant       *Grant    `json:"grant,omitempty"`
	ID          string    `json:"id"`
	Reason      *string   `json:"reason,omitempty"`
	RequestedAt time.Time `json:"requestedAt"`
	Requestor   string    `json:"requestor"`

	// The status of an Access Request.
	Status    RequestStatus `json:"status"`
	Timing    RequestTiming `json:"timing"`
	UpdatedAt time.Time     `json:"updatedAt"`
}

// Access Rule contains information for an end user to make a request for access.
type RequestAccessRule struct {
	Description string `json:"description"`
	ID          string `json:"id"`
	IsCurrent   bool   `json:"isCurrent"`
	Name        string `json:"name"`

	// A detailed target for an access rule request
	Target RequestAccessRuleTarget `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`

	// A unique version identifier for the Access Rule. Updating a rule creates a new version.
	// When a rule is updated, it's ID remains consistent.
	Version string `json:"version"`
}

// A detailed target for an access rule request
type RequestAccessRuleTarget struct {
	Arguments RequestAccessRuleTarget_Arguments `json:"arguments"`

	// Provider
	Provider Provider `json:"provider"`
}

// RequestAccessRuleTarget_Arguments defines model for RequestAccessRuleTarget.Arguments.
type RequestAccessRuleTarget_Arguments struct {
	AdditionalProperties map[string]RequestArgument `json:"-"`
}

// RequestArgument defines model for RequestArgument.
type RequestArgument struct {
	Description *string      `json:"description,omitempty"`
	Options     []WithOption `json:"options"`

	// This will be true if a selection is require when creating a request
	RequiresSelection bool   `json:"requiresSelection"`
	Title             string `json:"title"`
}

// A request to access something made by an end user in Granted.
type RequestDetail struct {
	// Access Rule contains information for an end user to make a request for access.
	AccessRule AccessRule `json:"accessRule"`

	// Describes whether a request has been approved automatically or from a review
	ApprovalMethod *ApprovalMethod         `json:"approvalMethod,omitempty"`
	Arguments      RequestDetail_Arguments `json:"arguments"`

	// true if the requesting user is a reviewer of this request.
	CanReview bool `json:"canReview"`

	// A temporary assignment of a user to a principal.
	Grant       *Grant    `json:"grant,omitempty"`
	ID          string    `json:"id"`
	Reason      *string   `json:"reason,omitempty"`
	RequestedAt time.Time `json:"requestedAt"`
	Requestor   string    `json:"requestor"`

	// The status of an Access Request.
	Status    RequestStatus `json:"status"`
	Timing    RequestTiming `json:"timing"`
	UpdatedAt time.Time     `json:"updatedAt"`
}

// RequestDetail_Arguments defines model for RequestDetail.Arguments.
type RequestDetail_Arguments struct {
	AdditionalProperties map[string]With `json:"-"`
}

// RequestEvent defines model for RequestEvent.
type RequestEvent struct {
	Actor     *string   `json:"actor,omitempty"`
	CreatedAt time.Time `json:"createdAt"`

	// The current state of the grant.
	FromGrantStatus *RequestEventFromGrantStatus `json:"fromGrantStatus,omitempty"`

	// The status of an Access Request.
	FromStatus         *RequestStatus `json:"fromStatus,omitempty"`
	FromTiming         *RequestTiming `json:"fromTiming,omitempty"`
	GrantCreated       *bool          `json:"grantCreated,omitempty"`
	GrantFailureReason *string        `json:"grantFailureReason,omitempty"`
	Id                 string         `json:"id"`

	// An event which was recorded relating to the grant.
	RecordedEvent  *map[string]string `json:"recordedEvent,omitempty"`
	RequestCreated *bool              `json:"requestCreated,omitempty"`
	RequestId      string             `json:"requestId"`

	// The current state of the grant.
	ToGrantStatus *RequestEventToGrantStatus `json:"toGrantStatus,omitempty"`

	// The status of an Access Request.
	ToStatus *RequestStatus `json:"toStatus,omitempty"`
	ToTiming *RequestTiming `json:"toTiming,omitempty"`
}

// The current state of the grant.
type RequestEventFromGrantStatus string

// The current state of the grant.
type RequestEventToGrantStatus string

// The status of an Access Request.
type RequestStatus string

// RequestTiming defines model for RequestTiming.
type RequestTiming struct {
	DurationSeconds int `json:"durationSeconds"`

	// iso8601 timestamp in UTC timezone
	StartTime *time.Time `json:"startTime,omitempty"`
}

// A decision made on an Access Request.
type ReviewDecision string

// Time configuration for an Access Rule.
type TimeConstraints struct {
	// The maximum duration in seconds the access is allowed for.
	MaxDurationSeconds int `json:"maxDurationSeconds"`
}

// User defines model for User.
type User struct {
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	Groups    []string  `json:"groups"`
	Id        string    `json:"id"`
	LastName  string    `json:"lastName"`
	Picture   string    `json:"picture"`
	Status    IdpStatus `json:"status"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// With defines model for With.
type With struct {
	FieldDescription  *string `json:"fieldDescription,omitempty"`
	Label             string  `json:"label"`
	OptionDescription *string `json:"optionDescription,omitempty"`
	Title             string  `json:"title"`
	Value             string  `json:"value"`
}

// WithOption defines model for WithOption.
type WithOption struct {
	Description *string `json:"description,omitempty"`
	Label       string  `json:"label"`
	Valid       bool    `json:"valid"`
	Value       string  `json:"value"`
}

// AuthUserResponse defines model for AuthUserResponse.
type AuthUserResponse struct {
	// Whether the user is an administrator of Granted.
	IsAdmin bool `json:"isAdmin"`
	User    User `json:"user"`
}

// CompleteProviderSetupResponse defines model for CompleteProviderSetupResponse.
type CompleteProviderSetupResponse struct {
	// Whether a manual update is required to the Granted Approvals deployment configuration (`granted-deployment.yml`) to activate the provider.
	DeploymentConfigUpdateRequired bool `json:"deploymentConfigUpdateRequired"`
}

// DeploymentVersionResponse defines model for DeploymentVersionResponse.
type DeploymentVersionResponse struct {
	// The deployment version. Will be a semver, such as "v0.9.0" for official releases, or "dev+GIT_HASH" for pre-release builds.
	Version string `json:"version"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error string `json:"error"`
}

// IdentityConfigurationResponse defines model for IdentityConfigurationResponse.
type IdentityConfigurationResponse struct {
	AdministratorGroupId string `json:"administratorGroupId"`
	IdentityProvider     string `json:"identityProvider"`
}

// ListAccessRuleApproversResponse defines model for ListAccessRuleApproversResponse.
type ListAccessRuleApproversResponse struct {
	Next  *string  `json:"next"`
	Users []string `json:"users"`
}

// ListAccessRulesDetailResponse defines model for ListAccessRulesDetailResponse.
type ListAccessRulesDetailResponse struct {
	AccessRules []AccessRuleDetail `json:"accessRules"`
	Next        *string            `json:"next"`
}

// ListAccessRulesResponse defines model for ListAccessRulesResponse.
type ListAccessRulesResponse struct {
	AccessRules []AccessRule `json:"accessRules"`
	Next        *string      `json:"next"`
}

// ListGroupsResponse defines model for ListGroupsResponse.
type ListGroupsResponse struct {
	Groups []Group `json:"groups"`
	Next   *string `json:"next"`
}

// ListProviderSetupsResponse defines model for ListProviderSetupsResponse.
type ListProviderSetupsResponse struct {
	ProviderSetups []ProviderSetup `json:"providerSetups"`
}

// ListRequestEventsResponse defines model for ListRequestEventsResponse.
type ListRequestEventsResponse struct {
	Events []RequestEvent `json:"events"`
	Next   *string        `json:"next"`
}

// ListRequestsResponse defines model for ListRequestsResponse.
type ListRequestsResponse struct {
	Next     *string   `json:"next"`
	Requests []Request `json:"requests"`
}

// ListUserResponse defines model for ListUserResponse.
type ListUserResponse struct {
	Next  *string `json:"next"`
	Users []User  `json:"users"`
}

// A provider in the process of being set up through the guided setup workflow in Granted. These providers are **not** yet active.
type ProviderSetupResponse = ProviderSetup

// ReviewResponse defines model for ReviewResponse.
type ReviewResponse struct {
	// A request to access something made by an end user in Granted.
	Request *Request `json:"request,omitempty"`
}

// CreateAccessRuleRequest defines model for CreateAccessRuleRequest.
type CreateAccessRuleRequest struct {
	// Approver config for access rules
	Approval    ApproverConfig `json:"approval"`
	Description string         `json:"description"`

	// The group IDs that the access rule applies to.
	Groups []string `json:"groups"`
	Name   string   `json:"name"`

	// a request body for creating a Access Rule Target
	Target CreateAccessRuleTarget `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`
}

// CreateGroupRequest defines model for CreateGroupRequest.
type CreateGroupRequest struct {
	Description *string  `json:"description,omitempty"`
	Id          *string  `json:"id,omitempty"`
	Members     []string `json:"members"`
	Name        string   `json:"name"`
}

// CreateProviderSetupRequest defines model for CreateProviderSetupRequest.
type CreateProviderSetupRequest struct {
	// The type of the provider to set up.
	ProviderType string `json:"providerType"`
}

// CreateRequestRequest defines model for CreateRequestRequest.
type CreateRequestRequest struct {
	AccessRuleId string             `json:"accessRuleId"`
	Reason       *string            `json:"reason,omitempty"`
	Timing       RequestTiming      `json:"timing"`
	With         *CreateRequestWith `json:"with,omitempty"`
}

// CreateUserRequest defines model for CreateUserRequest.
type CreateUserRequest struct {
	Email     openapi_types.Email `json:"email"`
	FirstName string              `json:"firstName"`
	IsAdmin   bool                `json:"isAdmin"`
	LastName  string              `json:"lastName"`
}

// ProviderSetupStepCompleteRequest defines model for ProviderSetupStepCompleteRequest.
type ProviderSetupStepCompleteRequest struct {
	// Whether the step is complete or not.
	Complete bool `json:"complete"`

	// The config values entered by the user which correspond to the setup step.
	ConfigValues map[string]string `json:"configValues"`
}

// ReviewRequest defines model for ReviewRequest.
type ReviewRequest struct {
	Comment *string `json:"comment,omitempty"`

	// A decision made on an Access Request.
	Decision       ReviewDecision `json:"decision"`
	OverrideTiming *RequestTiming `json:"overrideTiming,omitempty"`
}

// AccessRuleLookupParams defines parameters for AccessRuleLookup.
type AccessRuleLookupParams struct {
	// the provider type i.e. commonfate/aws-sso. type should be encoded i.e.  backslash -> %2
	Type *AccessRuleLookupParamsType `form:"type,omitempty" json:"type,omitempty"`

	// the permissionSetArn label, typically resembles a role name i.e. AdminstratorAccess
	PermissionSetArnLabel *string `form:"permissionSetArn.label,omitempty" json:"permissionSetArn.label,omitempty"`

	// the aws account id
	AccountId *string `form:"accountId,omitempty" json:"accountId,omitempty"`
}

// AccessRuleLookupParamsType defines parameters for AccessRuleLookup.
type AccessRuleLookupParamsType string

// AdminListAccessRulesParams defines parameters for AdminListAccessRules.
type AdminListAccessRulesParams struct {
	// Filter Access Rules by a particular status.
	Status *AdminListAccessRulesParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// AdminListAccessRulesParamsStatus defines parameters for AdminListAccessRules.
type AdminListAccessRulesParamsStatus string

// ListGroupsParams defines parameters for ListGroups.
type ListGroupsParams struct {
	// encrypted token containing pagination info
	NextToken *string                 `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Source    *ListGroupsParamsSource `form:"source,omitempty" json:"source,omitempty"`
}

// ListGroupsParamsSource defines parameters for ListGroups.
type ListGroupsParamsSource string

// ListProviderArgOptionsParams defines parameters for ListProviderArgOptions.
type ListProviderArgOptionsParams struct {
	// invalidate the cache and refresh the provider's options.
	Refresh *bool `form:"refresh,omitempty" json:"refresh,omitempty"`
}

// AdminListRequestsParams defines parameters for AdminListRequests.
type AdminListRequestsParams struct {
	// omit this param to view all results
	Status *AdminListRequestsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// AdminListRequestsParamsStatus defines parameters for AdminListRequests.
type AdminListRequestsParamsStatus string

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody struct {
	Groups []string `json:"groups"`
}

// UserListRequestsParams defines parameters for UserListRequests.
type UserListRequestsParams struct {
	// omit this param to view all results
	Status *UserListRequestsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// show requests that the user is a reviewer for, rather than requests that the user has made themselves
	Reviewer *bool `form:"reviewer,omitempty" json:"reviewer,omitempty"`

	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// UserListRequestsParamsStatus defines parameters for UserListRequests.
type UserListRequestsParamsStatus string

// UserListRequestsPastParams defines parameters for UserListRequestsPast.
type UserListRequestsPastParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// UserListRequestsUpcomingParams defines parameters for UserListRequestsUpcoming.
type UserListRequestsUpcomingParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// AdminCreateAccessRuleJSONRequestBody defines body for AdminCreateAccessRule for application/json ContentType.
type AdminCreateAccessRuleJSONRequestBody CreateAccessRuleRequest

// AdminUpdateAccessRuleJSONRequestBody defines body for AdminUpdateAccessRule for application/json ContentType.
type AdminUpdateAccessRuleJSONRequestBody CreateAccessRuleRequest

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupRequest

// CreateProvidersetupJSONRequestBody defines body for CreateProvidersetup for application/json ContentType.
type CreateProvidersetupJSONRequestBody CreateProviderSetupRequest

// SubmitProvidersetupStepJSONRequestBody defines body for SubmitProvidersetupStep for application/json ContentType.
type SubmitProvidersetupStepJSONRequestBody ProviderSetupStepCompleteRequest

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserRequest

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody UpdateUserJSONBody

// UserCreateRequestJSONRequestBody defines body for UserCreateRequest for application/json ContentType.
type UserCreateRequestJSONRequestBody CreateRequestRequest

// ReviewRequestJSONRequestBody defines body for ReviewRequest for application/json ContentType.
type ReviewRequestJSONRequestBody ReviewRequest

// Getter for additional properties for AccessRuleTargetDetail_With. Returns the specified
// element and whether it was found
func (a AccessRuleTargetDetail_With) Get(fieldName string) (value AccessRuleTargetDetailArguments, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AccessRuleTargetDetail_With
func (a *AccessRuleTargetDetail_With) Set(fieldName string, value AccessRuleTargetDetailArguments) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AccessRuleTargetDetailArguments)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AccessRuleTargetDetail_With to handle AdditionalProperties
func (a *AccessRuleTargetDetail_With) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AccessRuleTargetDetailArguments)
		for fieldName, fieldBuf := range object {
			var fieldVal AccessRuleTargetDetailArguments
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AccessRuleTargetDetail_With to handle AdditionalProperties
func (a AccessRuleTargetDetail_With) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AccessRuleTargetDetailArguments_Groupings. Returns the specified
// element and whether it was found
func (a AccessRuleTargetDetailArguments_Groupings) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AccessRuleTargetDetailArguments_Groupings
func (a *AccessRuleTargetDetailArguments_Groupings) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a *AccessRuleTargetDetailArguments_Groupings) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a AccessRuleTargetDetailArguments_Groupings) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateAccessRuleTarget_With. Returns the specified
// element and whether it was found
func (a CreateAccessRuleTarget_With) Get(fieldName string) (value CreateAccessRuleTargetDetailArguments, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateAccessRuleTarget_With
func (a *CreateAccessRuleTarget_With) Set(fieldName string, value CreateAccessRuleTargetDetailArguments) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]CreateAccessRuleTargetDetailArguments)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateAccessRuleTarget_With to handle AdditionalProperties
func (a *CreateAccessRuleTarget_With) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]CreateAccessRuleTargetDetailArguments)
		for fieldName, fieldBuf := range object {
			var fieldVal CreateAccessRuleTargetDetailArguments
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateAccessRuleTarget_With to handle AdditionalProperties
func (a CreateAccessRuleTarget_With) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateAccessRuleTargetDetailArguments_Groupings. Returns the specified
// element and whether it was found
func (a CreateAccessRuleTargetDetailArguments_Groupings) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateAccessRuleTargetDetailArguments_Groupings
func (a *CreateAccessRuleTargetDetailArguments_Groupings) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateAccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a *CreateAccessRuleTargetDetailArguments_Groupings) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateAccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a CreateAccessRuleTargetDetailArguments_Groupings) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateRequestWith. Returns the specified
// element and whether it was found
func (a CreateRequestWith) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateRequestWith
func (a *CreateRequestWith) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateRequestWith to handle AdditionalProperties
func (a *CreateRequestWith) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateRequestWith to handle AdditionalProperties
func (a CreateRequestWith) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RequestAccessRuleTarget_Arguments. Returns the specified
// element and whether it was found
func (a RequestAccessRuleTarget_Arguments) Get(fieldName string) (value RequestArgument, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RequestAccessRuleTarget_Arguments
func (a *RequestAccessRuleTarget_Arguments) Set(fieldName string, value RequestArgument) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]RequestArgument)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RequestAccessRuleTarget_Arguments to handle AdditionalProperties
func (a *RequestAccessRuleTarget_Arguments) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]RequestArgument)
		for fieldName, fieldBuf := range object {
			var fieldVal RequestArgument
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RequestAccessRuleTarget_Arguments to handle AdditionalProperties
func (a RequestAccessRuleTarget_Arguments) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RequestDetail_Arguments. Returns the specified
// element and whether it was found
func (a RequestDetail_Arguments) Get(fieldName string) (value With, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RequestDetail_Arguments
func (a *RequestDetail_Arguments) Set(fieldName string, value With) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]With)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RequestDetail_Arguments to handle AdditionalProperties
func (a *RequestDetail_Arguments) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]With)
		for fieldName, fieldBuf := range object {
			var fieldVal With
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RequestDetail_Arguments to handle AdditionalProperties
func (a RequestDetail_Arguments) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List Access Rules
	// (GET /api/v1/access-rules)
	ListUserAccessRules(w http.ResponseWriter, r *http.Request)
	// Lookup an access rule based on the target
	// (GET /api/v1/access-rules/lookup)
	AccessRuleLookup(w http.ResponseWriter, r *http.Request, params AccessRuleLookupParams)
	// Get Access Rule
	// (GET /api/v1/access-rules/{ruleId})
	UserGetAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// List Access Rule approvers
	// (GET /api/v1/access-rules/{ruleId}/approvers)
	UserGetAccessRuleApprovers(w http.ResponseWriter, r *http.Request, ruleId string)
	// List Access Rules
	// (GET /api/v1/admin/access-rules)
	AdminListAccessRules(w http.ResponseWriter, r *http.Request, params AdminListAccessRulesParams)
	// Create Access Rule
	// (POST /api/v1/admin/access-rules)
	AdminCreateAccessRule(w http.ResponseWriter, r *http.Request)
	// Get Access Rule
	// (GET /api/v1/admin/access-rules/{ruleId})
	AdminGetAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Update Access Rule
	// (PUT /api/v1/admin/access-rules/{ruleId})
	AdminUpdateAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Archive Access Rule
	// (POST /api/v1/admin/access-rules/{ruleId}/archive)
	AdminArchiveAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Get Access Rule version history
	// (GET /api/v1/admin/access-rules/{ruleId}/versions)
	AdminGetAccessRuleVersions(w http.ResponseWriter, r *http.Request, ruleId string)
	// Get Access Rule Version
	// (GET /api/v1/admin/access-rules/{ruleId}/versions/{version})
	AdminGetAccessRuleVersion(w http.ResponseWriter, r *http.Request, ruleId string, version string)
	// Get deployment version details
	// (GET /api/v1/admin/deployment/version)
	AdminGetDeploymentVersion(w http.ResponseWriter, r *http.Request)
	// List groups
	// (GET /api/v1/admin/groups)
	ListGroups(w http.ResponseWriter, r *http.Request, params ListGroupsParams)
	// Create Group
	// (POST /api/v1/admin/groups)
	CreateGroup(w http.ResponseWriter, r *http.Request)
	// Get Group Details
	// (GET /api/v1/admin/groups/{groupId})
	GetGroup(w http.ResponseWriter, r *http.Request, groupId string)
	// Get identity configuration
	// (GET /api/v1/admin/identity)
	IdentityConfiguration(w http.ResponseWriter, r *http.Request)
	// Sync Identity
	// (POST /api/v1/admin/identity/sync)
	IdentitySync(w http.ResponseWriter, r *http.Request)
	// List providers
	// (GET /api/v1/admin/providers)
	ListProviders(w http.ResponseWriter, r *http.Request)
	// List providers
	// (GET /api/v1/admin/providers/{providerId})
	GetProvider(w http.ResponseWriter, r *http.Request, providerId string)
	// Get provider arg schema
	// (GET /api/v1/admin/providers/{providerId}/args)
	GetProviderArgs(w http.ResponseWriter, r *http.Request, providerId string)
	// List provider arg options
	// (GET /api/v1/admin/providers/{providerId}/args/{argId}/options)
	ListProviderArgOptions(w http.ResponseWriter, r *http.Request, providerId string, argId string, params ListProviderArgOptionsParams)
	// List the provider setups in progress
	// (GET /api/v1/admin/providersetups)
	ListProvidersetups(w http.ResponseWriter, r *http.Request)
	// Begin the setup process for a new Access Provider
	// (POST /api/v1/admin/providersetups)
	CreateProvidersetup(w http.ResponseWriter, r *http.Request)
	// Delete an in-progress provider setup
	// (DELETE /api/v1/admin/providersetups/{providersetupId})
	DeleteProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Get an in-progress provider setup
	// (GET /api/v1/admin/providersetups/{providersetupId})
	GetProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Complete a ProviderSetup
	// (POST /api/v1/admin/providersetups/{providersetupId}/complete)
	CompleteProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Get the setup instructions for an Access Provider
	// (GET /api/v1/admin/providersetups/{providersetupId}/instructions)
	GetProvidersetupInstructions(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Update the completion status for a Provider setup step
	// (PUT /api/v1/admin/providersetups/{providersetupId}/steps/{stepIndex}/complete)
	SubmitProvidersetupStep(w http.ResponseWriter, r *http.Request, providersetupId string, stepIndex int)
	// Validate the configuration for a Provider Setup
	// (POST /api/v1/admin/providersetups/{providersetupId}/validate)
	ValidateProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Your GET endpoint
	// (GET /api/v1/admin/requests)
	AdminListRequests(w http.ResponseWriter, r *http.Request, params AdminListRequestsParams)
	// Get a request
	// (GET /api/v1/admin/requests/{requestId})
	AdminGetRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// Returns a list of users
	// (GET /api/v1/admin/users)
	GetUsers(w http.ResponseWriter, r *http.Request, params GetUsersParams)
	// Create User
	// (POST /api/v1/admin/users)
	CreateUser(w http.ResponseWriter, r *http.Request)
	// Update User
	// (POST /api/v1/admin/users/{userId})
	UpdateUser(w http.ResponseWriter, r *http.Request, userId string)
	// List my requests
	// (GET /api/v1/requests)
	UserListRequests(w http.ResponseWriter, r *http.Request, params UserListRequestsParams)
	// Create a request
	// (POST /api/v1/requests)
	UserCreateRequest(w http.ResponseWriter, r *http.Request)
	// Your GET endpoint
	// (GET /api/v1/requests/past)
	UserListRequestsPast(w http.ResponseWriter, r *http.Request, params UserListRequestsPastParams)
	// Your GET endpoint
	// (GET /api/v1/requests/upcoming)
	UserListRequestsUpcoming(w http.ResponseWriter, r *http.Request, params UserListRequestsUpcomingParams)
	// Get a request
	// (GET /api/v1/requests/{requestId})
	UserGetRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// Get Access Instructions
	// (GET /api/v1/requests/{requestId}/access-instructions)
	GetAccessInstructions(w http.ResponseWriter, r *http.Request, requestId string)
	// Get Access Token
	// (GET /api/v1/requests/{requestId}/access-token)
	GetAccessToken(w http.ResponseWriter, r *http.Request, requestId string)
	// Cancel a request
	// (POST /api/v1/requests/{requestId}/cancel)
	CancelRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// List request events
	// (GET /api/v1/requests/{requestId}/events)
	ListRequestEvents(w http.ResponseWriter, r *http.Request, requestId string)
	// Review a request
	// (POST /api/v1/requests/{requestId}/review)
	ReviewRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// Revoke an active request
	// (POST /api/v1/requests/{requestid}/revoke)
	RevokeRequest(w http.ResponseWriter, r *http.Request, requestid string)
	// Get details for the current user
	// (GET /api/v1/users/me)
	GetMe(w http.ResponseWriter, r *http.Request)
	// Get a user
	// (GET /api/v1/users/{userId})
	GetUser(w http.ResponseWriter, r *http.Request, userId string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// ListUserAccessRules operation middleware
func (siw *ServerInterfaceWrapper) ListUserAccessRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserAccessRules(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AccessRuleLookup operation middleware
func (siw *ServerInterfaceWrapper) AccessRuleLookup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AccessRuleLookupParams

	// ------------- Optional query parameter "type" -------------
	if paramValue := r.URL.Query().Get("type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	// ------------- Optional query parameter "permissionSetArn.label" -------------
	if paramValue := r.URL.Query().Get("permissionSetArn.label"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "permissionSetArn.label", r.URL.Query(), &params.PermissionSetArnLabel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "permissionSetArn.label", Err: err})
		return
	}

	// ------------- Optional query parameter "accountId" -------------
	if paramValue := r.URL.Query().Get("accountId"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "accountId", r.URL.Query(), &params.AccountId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccessRuleLookup(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetAccessRule operation middleware
func (siw *ServerInterfaceWrapper) UserGetAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetAccessRuleApprovers operation middleware
func (siw *ServerInterfaceWrapper) UserGetAccessRuleApprovers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetAccessRuleApprovers(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminListAccessRules operation middleware
func (siw *ServerInterfaceWrapper) AdminListAccessRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminListAccessRulesParams

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminListAccessRules(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminCreateAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminCreateAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminCreateAccessRule(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminGetAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminUpdateAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminUpdateAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminUpdateAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminArchiveAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminArchiveAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminArchiveAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetAccessRuleVersions operation middleware
func (siw *ServerInterfaceWrapper) AdminGetAccessRuleVersions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetAccessRuleVersions(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetAccessRuleVersion operation middleware
func (siw *ServerInterfaceWrapper) AdminGetAccessRuleVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameter("simple", false, "version", chi.URLParam(r, "version"), &version)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetAccessRuleVersion(w, r, ruleId, version)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetDeploymentVersion operation middleware
func (siw *ServerInterfaceWrapper) AdminGetDeploymentVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetDeploymentVersion(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListGroups operation middleware
func (siw *ServerInterfaceWrapper) ListGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupsParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	// ------------- Optional query parameter "source" -------------
	if paramValue := r.URL.Query().Get("source"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "source", r.URL.Query(), &params.Source)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "source", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroups(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateGroup operation middleware
func (siw *ServerInterfaceWrapper) CreateGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGroup(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGroup operation middleware
func (siw *ServerInterfaceWrapper) GetGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroup(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// IdentityConfiguration operation middleware
func (siw *ServerInterfaceWrapper) IdentityConfiguration(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.IdentityConfiguration(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// IdentitySync operation middleware
func (siw *ServerInterfaceWrapper) IdentitySync(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.IdentitySync(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListProviders operation middleware
func (siw *ServerInterfaceWrapper) ListProviders(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProviders(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProvider operation middleware
func (siw *ServerInterfaceWrapper) GetProvider(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providerId" -------------
	var providerId string

	err = runtime.BindStyledParameter("simple", false, "providerId", chi.URLParam(r, "providerId"), &providerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providerId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProvider(w, r, providerId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProviderArgs operation middleware
func (siw *ServerInterfaceWrapper) GetProviderArgs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providerId" -------------
	var providerId string

	err = runtime.BindStyledParameter("simple", false, "providerId", chi.URLParam(r, "providerId"), &providerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providerId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProviderArgs(w, r, providerId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListProviderArgOptions operation middleware
func (siw *ServerInterfaceWrapper) ListProviderArgOptions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providerId" -------------
	var providerId string

	err = runtime.BindStyledParameter("simple", false, "providerId", chi.URLParam(r, "providerId"), &providerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providerId", Err: err})
		return
	}

	// ------------- Path parameter "argId" -------------
	var argId string

	err = runtime.BindStyledParameter("simple", false, "argId", chi.URLParam(r, "argId"), &argId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "argId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProviderArgOptionsParams

	// ------------- Optional query parameter "refresh" -------------
	if paramValue := r.URL.Query().Get("refresh"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "refresh", r.URL.Query(), &params.Refresh)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "refresh", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProviderArgOptions(w, r, providerId, argId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListProvidersetups operation middleware
func (siw *ServerInterfaceWrapper) ListProvidersetups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProvidersetups(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) CreateProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProvidersetup(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) DeleteProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) GetProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CompleteProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) CompleteProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CompleteProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProvidersetupInstructions operation middleware
func (siw *ServerInterfaceWrapper) GetProvidersetupInstructions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProvidersetupInstructions(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SubmitProvidersetupStep operation middleware
func (siw *ServerInterfaceWrapper) SubmitProvidersetupStep(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	// ------------- Path parameter "stepIndex" -------------
	var stepIndex int

	err = runtime.BindStyledParameter("simple", false, "stepIndex", chi.URLParam(r, "stepIndex"), &stepIndex)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "stepIndex", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SubmitProvidersetupStep(w, r, providersetupId, stepIndex)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ValidateProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) ValidateProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ValidateProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminListRequests operation middleware
func (siw *ServerInterfaceWrapper) AdminListRequests(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminListRequestsParams

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminListRequests(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetRequest operation middleware
func (siw *ServerInterfaceWrapper) AdminGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUsers operation middleware
func (siw *ServerInterfaceWrapper) GetUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUsers(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateUser operation middleware
func (siw *ServerInterfaceWrapper) CreateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUser(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateUser operation middleware
func (siw *ServerInterfaceWrapper) UpdateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserListRequests operation middleware
func (siw *ServerInterfaceWrapper) UserListRequests(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListRequestsParams

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "reviewer" -------------
	if paramValue := r.URL.Query().Get("reviewer"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "reviewer", r.URL.Query(), &params.Reviewer)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "reviewer", Err: err})
		return
	}

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListRequests(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserCreateRequest operation middleware
func (siw *ServerInterfaceWrapper) UserCreateRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserCreateRequest(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserListRequestsPast operation middleware
func (siw *ServerInterfaceWrapper) UserListRequestsPast(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListRequestsPastParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListRequestsPast(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserListRequestsUpcoming operation middleware
func (siw *ServerInterfaceWrapper) UserListRequestsUpcoming(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListRequestsUpcomingParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListRequestsUpcoming(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetRequest operation middleware
func (siw *ServerInterfaceWrapper) UserGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetAccessInstructions operation middleware
func (siw *ServerInterfaceWrapper) GetAccessInstructions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAccessInstructions(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetAccessToken operation middleware
func (siw *ServerInterfaceWrapper) GetAccessToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAccessToken(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CancelRequest operation middleware
func (siw *ServerInterfaceWrapper) CancelRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CancelRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListRequestEvents operation middleware
func (siw *ServerInterfaceWrapper) ListRequestEvents(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRequestEvents(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ReviewRequest operation middleware
func (siw *ServerInterfaceWrapper) ReviewRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReviewRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RevokeRequest operation middleware
func (siw *ServerInterfaceWrapper) RevokeRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestid" -------------
	var requestid string

	err = runtime.BindStyledParameter("simple", false, "requestid", chi.URLParam(r, "requestid"), &requestid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestid", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RevokeRequest(w, r, requestid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetMe operation middleware
func (siw *ServerInterfaceWrapper) GetMe(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMe(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUser operation middleware
func (siw *ServerInterfaceWrapper) GetUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules", wrapper.ListUserAccessRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules/lookup", wrapper.AccessRuleLookup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules/{ruleId}", wrapper.UserGetAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules/{ruleId}/approvers", wrapper.UserGetAccessRuleApprovers)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules", wrapper.AdminListAccessRules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/access-rules", wrapper.AdminCreateAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}", wrapper.AdminGetAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}", wrapper.AdminUpdateAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}/archive", wrapper.AdminArchiveAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}/versions", wrapper.AdminGetAccessRuleVersions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}/versions/{version}", wrapper.AdminGetAccessRuleVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/deployment/version", wrapper.AdminGetDeploymentVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/groups", wrapper.ListGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/groups", wrapper.CreateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/groups/{groupId}", wrapper.GetGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/identity", wrapper.IdentityConfiguration)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/identity/sync", wrapper.IdentitySync)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers", wrapper.ListProviders)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers/{providerId}", wrapper.GetProvider)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers/{providerId}/args", wrapper.GetProviderArgs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers/{providerId}/args/{argId}/options", wrapper.ListProviderArgOptions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providersetups", wrapper.ListProvidersetups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/providersetups", wrapper.CreateProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}", wrapper.DeleteProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}", wrapper.GetProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/complete", wrapper.CompleteProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/instructions", wrapper.GetProvidersetupInstructions)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/steps/{stepIndex}/complete", wrapper.SubmitProvidersetupStep)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/validate", wrapper.ValidateProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/requests", wrapper.AdminListRequests)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/requests/{requestId}", wrapper.AdminGetRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/users", wrapper.GetUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/users", wrapper.CreateUser)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/users/{userId}", wrapper.UpdateUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests", wrapper.UserListRequests)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests", wrapper.UserCreateRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/past", wrapper.UserListRequestsPast)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/upcoming", wrapper.UserListRequestsUpcoming)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}", wrapper.UserGetRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}/access-instructions", wrapper.GetAccessInstructions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}/access-token", wrapper.GetAccessToken)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests/{requestId}/cancel", wrapper.CancelRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}/events", wrapper.ListRequestEvents)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests/{requestId}/review", wrapper.ReviewRequest)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests/{requestid}/revoke", wrapper.RevokeRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/users/me", wrapper.GetMe)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/users/{userId}", wrapper.GetUser)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	pathPrefix := path.Dir(pathToFile)

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(pathPrefix, "./accesshandler/openapi.yml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
