// Package types provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package types

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	externalRef0 "github.com/common-fate/granted-approvals/accesshandler/pkg/types"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// Defines values for AccessRuleStatus.
const (
	AccessRuleStatusACTIVE   AccessRuleStatus = "ACTIVE"
	AccessRuleStatusARCHIVED AccessRuleStatus = "ARCHIVED"
)

// Defines values for ApprovalMethod.
const (
	AUTOMATIC ApprovalMethod = "AUTOMATIC"
	REVIEWED  ApprovalMethod = "REVIEWED"
)

// Defines values for GrantStatus.
const (
	GrantStatusACTIVE  GrantStatus = "ACTIVE"
	GrantStatusERROR   GrantStatus = "ERROR"
	GrantStatusEXPIRED GrantStatus = "EXPIRED"
	GrantStatusPENDING GrantStatus = "PENDING"
	GrantStatusREVOKED GrantStatus = "REVOKED"
)

// Defines values for IdpStatus.
const (
	IdpStatusACTIVE   IdpStatus = "ACTIVE"
	IdpStatusARCHIVED IdpStatus = "ARCHIVED"
)

// Defines values for ProviderSetupStatus.
const (
	COMPLETE                       ProviderSetupStatus = "COMPLETE"
	INITIALCONFIGURATIONINPROGRESS ProviderSetupStatus = "INITIAL_CONFIGURATION_IN_PROGRESS"
	VALIDATING                     ProviderSetupStatus = "VALIDATING"
	VALIDATIONFAILED               ProviderSetupStatus = "VALIDATION_FAILED"
	VALIDATIONSUCEEDED             ProviderSetupStatus = "VALIDATION_SUCEEDED"
)

// Defines values for ProviderSetupDiagnosticLogLevel.
const (
	ProviderSetupDiagnosticLogLevelERROR   ProviderSetupDiagnosticLogLevel = "ERROR"
	ProviderSetupDiagnosticLogLevelINFO    ProviderSetupDiagnosticLogLevel = "INFO"
	ProviderSetupDiagnosticLogLevelWARNING ProviderSetupDiagnosticLogLevel = "WARNING"
)

// Defines values for ProviderSetupValidationStatus.
const (
	ProviderSetupValidationStatusERROR      ProviderSetupValidationStatus = "ERROR"
	ProviderSetupValidationStatusINPROGRESS ProviderSetupValidationStatus = "IN_PROGRESS"
	ProviderSetupValidationStatusPENDING    ProviderSetupValidationStatus = "PENDING"
	ProviderSetupValidationStatusSUCCESS    ProviderSetupValidationStatus = "SUCCESS"
)

// Defines values for RequestEventFromGrantStatus.
const (
	RequestEventFromGrantStatusACTIVE  RequestEventFromGrantStatus = "ACTIVE"
	RequestEventFromGrantStatusERROR   RequestEventFromGrantStatus = "ERROR"
	RequestEventFromGrantStatusEXPIRED RequestEventFromGrantStatus = "EXPIRED"
	RequestEventFromGrantStatusPENDING RequestEventFromGrantStatus = "PENDING"
	RequestEventFromGrantStatusREVOKED RequestEventFromGrantStatus = "REVOKED"
)

// Defines values for RequestEventToGrantStatus.
const (
	RequestEventToGrantStatusACTIVE  RequestEventToGrantStatus = "ACTIVE"
	RequestEventToGrantStatusERROR   RequestEventToGrantStatus = "ERROR"
	RequestEventToGrantStatusEXPIRED RequestEventToGrantStatus = "EXPIRED"
	RequestEventToGrantStatusPENDING RequestEventToGrantStatus = "PENDING"
	RequestEventToGrantStatusREVOKED RequestEventToGrantStatus = "REVOKED"
)

// Defines values for RequestStatus.
const (
	RequestStatusAPPROVED  RequestStatus = "APPROVED"
	RequestStatusCANCELLED RequestStatus = "CANCELLED"
	RequestStatusDECLINED  RequestStatus = "DECLINED"
	RequestStatusPENDING   RequestStatus = "PENDING"
)

// Defines values for ReviewDecision.
const (
	APPROVED ReviewDecision = "APPROVED"
	DECLINED ReviewDecision = "DECLINED"
)

// Access Rule contains information for an end user to make a request for access.
type AccessRule struct {
	Description string `json:"description"`
	ID          string `json:"id"`
	IsCurrent   bool   `json:"isCurrent"`
	Name        string `json:"name"`

	// A target for an access rule
	Target AccessRuleTarget `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`

	// A unique version identifier for the Access Rule. Updating a rule creates a new version.
	// When a rule is updated, it's ID remains consistent.
	Version string `json:"version"`
}

// AccessRuleDetail contains detailed information about a rule and is used in administrative apis.
type AccessRuleDetail struct {
	// Approver config for access rules
	Approval    ApproverConfig `json:"approval"`
	Description string         `json:"description"`

	// The group IDs that the access rule applies to.
	Groups    []string           `json:"groups"`
	ID        string             `json:"id"`
	IsCurrent bool               `json:"isCurrent"`
	Metadata  AccessRuleMetadata `json:"metadata"`
	Name      string             `json:"name"`

	// The status of an Access Rule.
	Status AccessRuleStatus `json:"status"`

	// A target for an access rule
	Target AccessRuleTarget `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`

	// A unique version identifier for the Access Rule. Updating a rule creates a new version.
	// When a rule is updated, it's ID remains consistent.
	Version string `json:"version"`
}

// AccessRuleMetadata defines model for AccessRuleMetadata.
type AccessRuleMetadata struct {
	CreatedAt     time.Time `json:"createdAt"`
	CreatedBy     string    `json:"createdBy"`
	UpdateMessage *string   `json:"updateMessage,omitempty"`
	UpdatedAt     time.Time `json:"updatedAt"`
	UpdatedBy     string    `json:"updatedBy"`
}

// The status of an Access Rule.
type AccessRuleStatus string

// A target for an access rule
type AccessRuleTarget struct {
	// Provider
	Provider Provider `json:"provider"`
}

// A detailed target for an access rule
type AccessRuleTargetDetail struct {
	// Provider
	Provider Provider                    `json:"provider"`
	With     AccessRuleTargetDetail_With `json:"with"`
}

// AccessRuleTargetDetail_With defines model for AccessRuleTargetDetail.With.
type AccessRuleTargetDetail_With struct {
	AdditionalProperties map[string]AccessRuleTargetDetailArguments `json:"-"`
}

// AccessRuleTargetDetailArguments defines model for AccessRuleTargetDetailArguments.
type AccessRuleTargetDetailArguments struct {
	Groupings AccessRuleTargetDetailArguments_Groupings `json:"groupings"`
	Values    []string                                  `json:"values"`
}

// AccessRuleTargetDetailArguments_Groupings defines model for AccessRuleTargetDetailArguments.Groupings.
type AccessRuleTargetDetailArguments_Groupings struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// AccessToken defines model for AccessToken.
type AccessToken = string

// Describes whether a request has been approved automatically or from a review
type ApprovalMethod string

// Approver config for access rules
type ApproverConfig struct {
	Groups []string `json:"groups"`

	// The user IDs of the approvers for the request.
	Users []string `json:"users"`
}

// a request body for creating a Access Rule Target
type CreateAccessRuleTarget struct {
	ProviderId string                      `json:"providerId"`
	With       CreateAccessRuleTarget_With `json:"with"`
}

// CreateAccessRuleTarget_With defines model for CreateAccessRuleTarget.With.
type CreateAccessRuleTarget_With struct {
	AdditionalProperties map[string]AccessRuleTargetDetailArguments `json:"-"`
}

// CreateRequestWith defines model for CreateRequestWith.
type CreateRequestWith struct {
	AdditionalProperties map[string]string `json:"-"`
}

// A temporary assignment of a user to a principal.
type Grant struct {
	// The end time of the grant.
	End time.Time `json:"end"`

	// The ID of the provider to grant access to.
	Provider string `json:"provider"`

	// The start time of the grant.
	Start time.Time `json:"start"`

	// The current state of the grant.
	Status GrantStatus `json:"status"`

	// The email address of the user to grant access to.
	Subject openapi_types.Email `json:"subject"`
}

// The current state of the grant.
type GrantStatus string

// Group defines model for Group.
type Group struct {
	Description string `json:"description"`
	Id          string `json:"id"`
	MemberCount int    `json:"memberCount"`
	Name        string `json:"name"`
}

// IdpStatus defines model for IdpStatus.
type IdpStatus string

// KeyValue defines model for KeyValue.
type KeyValue struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// A matched access rule with option values if they are required for the access rule request
type LookupAccessRule struct {
	// Access Rule contains information for an end user to make a request for access.
	AccessRule AccessRule `json:"accessRule"`

	// If the matched access rule has selectable fields, this array will contain the matched values to be used to prefill the form when requesting
	SelectableWithOptionValues *[]KeyValue `json:"selectableWithOptionValues,omitempty"`
}

// Provider
type Provider struct {
	Id   string `json:"id"`
	Type string `json:"type"`
}

// ProviderConfigField defines model for ProviderConfigField.
type ProviderConfigField struct {
	Description string `json:"description"`
	Id          string `json:"id"`

	// Whether the config value is optional.
	IsOptional bool `json:"isOptional"`

	// Whether or not the config field is a secret (like an API key or a password)
	IsSecret bool   `json:"isSecret"`
	Name     string `json:"name"`

	// the path to where the secret will be stored, in a secrets manager like AWS SSM Parameter Store.
	SecretPath *string `json:"secretPath,omitempty"`
}

// ProviderConfigValue defines model for ProviderConfigValue.
type ProviderConfigValue struct {
	// The ID of the config field.
	Id string `json:"id"`

	// The value entered by the user.
	Value string `json:"value"`
}

// A provider in the process of being set up through the guided setup workflow in Granted. These providers are **not** yet active.
type ProviderSetup struct {
	ConfigValidation []externalRef0.ProviderConfigValidation `json:"configValidation"`

	// The current configuration values.
	ConfigValues map[string]string `json:"configValues"`

	// A unique ID for the provider setup. This is a random KSUID to avoid potential conflicts with user-specified provider IDs in the `granted-deployment.yml` file.
	Id string `json:"id"`

	// The status of the setup process.
	Status ProviderSetupStatus `json:"status"`

	// An overview of the steps indicating whether they are complete.
	Steps []ProviderSetupStepOverview `json:"steps"`

	// The type of the Access Provider being set up.
	Type string `json:"type"`

	// The version of the provider.
	Version string `json:"version"`
}

// The status of the setup process.
type ProviderSetupStatus string

// A log entry related to a provider setup validation.
type ProviderSetupDiagnosticLog struct {
	// The log level.
	Level ProviderSetupDiagnosticLogLevel `json:"level"`

	// The log message.
	Msg string `json:"msg"`
}

// The log level.
type ProviderSetupDiagnosticLogLevel string

// ProviderSetupInstructions defines model for ProviderSetupInstructions.
type ProviderSetupInstructions struct {
	StepDetails []ProviderSetupStepDetails `json:"stepDetails"`
}

// ProviderSetupStepDetails defines model for ProviderSetupStepDetails.
type ProviderSetupStepDetails struct {
	ConfigFields []ProviderConfigField `json:"configFields"`
	Instructions string                `json:"instructions"`
	Title        string                `json:"title"`
}

// Indicates whether a setup step is complete or not.
type ProviderSetupStepOverview struct {
	// Whether the step has been completed.
	Complete bool `json:"complete"`
}

// A validation against the configuration values of the Access Provider.
type ProviderSetupValidation struct {
	// The particular config fields validated, if any.
	FieldsValidated []interface{} `json:"fieldsValidated"`

	// The ID of the validation, such as `list-sso-users`.
	Id   string                        `json:"id"`
	Logs *[]ProviderSetupDiagnosticLog `json:"logs,omitempty"`

	// The status of the validation.
	Status ProviderSetupValidationStatus `json:"status"`
}

// The status of the validation.
type ProviderSetupValidationStatus string

// A request to access something made by an end user in Granted.
type Request struct {
	// Access Rule contains information for an end user to make a request for access.
	AccessRule AccessRule `json:"accessRule"`

	// Describes whether a request has been approved automatically or from a review
	ApprovalMethod *ApprovalMethod `json:"approvalMethod,omitempty"`

	// A temporary assignment of a user to a principal.
	Grant       *Grant    `json:"grant,omitempty"`
	ID          string    `json:"id"`
	Reason      *string   `json:"reason,omitempty"`
	RequestedAt time.Time `json:"requestedAt"`
	Requestor   string    `json:"requestor"`

	// The status of an Access Request.
	Status    RequestStatus `json:"status"`
	Timing    RequestTiming `json:"timing"`
	UpdatedAt time.Time     `json:"updatedAt"`
}

// Access Rule contains information for an end user to make a request for access.
type RequestAccessRule struct {
	Description string `json:"description"`
	ID          string `json:"id"`
	IsCurrent   bool   `json:"isCurrent"`
	Name        string `json:"name"`

	// A target for an access rule
	Target AccessRuleTarget `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`

	// A unique version identifier for the Access Rule. Updating a rule creates a new version.
	// When a rule is updated, it's ID remains consistent.
	Version string `json:"version"`
}

// A detailed target for an access rule request
type RequestAccessRuleTarget struct {
	Arguments RequestAccessRuleTarget_Arguments `json:"arguments"`

	// Provider
	Provider Provider `json:"provider"`
}

// RequestAccessRuleTarget_Arguments defines model for RequestAccessRuleTarget.Arguments.
type RequestAccessRuleTarget_Arguments struct {
	AdditionalProperties map[string]RequestArgument `json:"-"`
}

// RequestArgument defines model for RequestArgument.
type RequestArgument struct {
	Description string       `json:"description"`
	Options     []WithOption `json:"options"`
	Title       string       `json:"title"`
}

// A request to access something made by an end user in Granted.
type RequestDetail struct {
	// Access Rule contains information for an end user to make a request for access.
	AccessRule AccessRule `json:"accessRule"`

	// Describes whether a request has been approved automatically or from a review
	ApprovalMethod *ApprovalMethod         `json:"approvalMethod,omitempty"`
	Arguments      RequestDetail_Arguments `json:"arguments"`

	// true if the requesting user is a reviewer of this request.
	CanReview bool `json:"canReview"`

	// A temporary assignment of a user to a principal.
	Grant       *Grant    `json:"grant,omitempty"`
	ID          string    `json:"id"`
	Reason      *string   `json:"reason,omitempty"`
	RequestedAt time.Time `json:"requestedAt"`
	Requestor   string    `json:"requestor"`

	// The status of an Access Request.
	Status    RequestStatus `json:"status"`
	Timing    RequestTiming `json:"timing"`
	UpdatedAt time.Time     `json:"updatedAt"`
}

// RequestDetail_Arguments defines model for RequestDetail.Arguments.
type RequestDetail_Arguments struct {
	AdditionalProperties map[string]With `json:"-"`
}

// RequestEvent defines model for RequestEvent.
type RequestEvent struct {
	Actor     *string   `json:"actor,omitempty"`
	CreatedAt time.Time `json:"createdAt"`

	// The current state of the grant.
	FromGrantStatus *RequestEventFromGrantStatus `json:"fromGrantStatus,omitempty"`

	// The status of an Access Request.
	FromStatus         *RequestStatus `json:"fromStatus,omitempty"`
	FromTiming         *RequestTiming `json:"fromTiming,omitempty"`
	GrantCreated       *bool          `json:"grantCreated,omitempty"`
	GrantFailureReason *string        `json:"grantFailureReason,omitempty"`
	Id                 string         `json:"id"`

	// An event which was recorded relating to the grant.
	RecordedEvent  *map[string]string `json:"recordedEvent,omitempty"`
	RequestCreated *bool              `json:"requestCreated,omitempty"`
	RequestId      string             `json:"requestId"`

	// The current state of the grant.
	ToGrantStatus *RequestEventToGrantStatus `json:"toGrantStatus,omitempty"`

	// The status of an Access Request.
	ToStatus *RequestStatus `json:"toStatus,omitempty"`
	ToTiming *RequestTiming `json:"toTiming,omitempty"`
}

// The current state of the grant.
type RequestEventFromGrantStatus string

// The current state of the grant.
type RequestEventToGrantStatus string

// The status of an Access Request.
type RequestStatus string

// RequestTiming defines model for RequestTiming.
type RequestTiming struct {
	DurationSeconds int `json:"durationSeconds"`

	// iso8601 timestamp in UTC timezone
	StartTime *time.Time `json:"startTime,omitempty"`
}

// A decision made on an Access Request.
type ReviewDecision string

// Selectable defines model for Selectable.
type Selectable struct {
	Options []WithOption `json:"options"`
	Title   string       `json:"title"`
}

// Time configuration for an Access Rule.
type TimeConstraints struct {
	// The maximum duration in seconds the access is allowed for.
	MaxDurationSeconds int `json:"maxDurationSeconds"`
}

// User defines model for User.
type User struct {
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	Groups    []string  `json:"groups"`
	Id        string    `json:"id"`
	LastName  string    `json:"lastName"`
	Picture   string    `json:"picture"`
	Status    IdpStatus `json:"status"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// With defines model for With.
type With struct {
	FieldDescription  *string `json:"fieldDescription,omitempty"`
	Label             string  `json:"label"`
	OptionDescription *string `json:"optionDescription,omitempty"`
	Title             string  `json:"title"`
	Value             string  `json:"value"`
}

// WithOption defines model for WithOption.
type WithOption struct {
	Label string `json:"label"`
	Valid bool   `json:"valid"`
	Value string `json:"value"`
}

// AuthUserResponse defines model for AuthUserResponse.
type AuthUserResponse struct {
	// Whether the user is an administrator of Granted.
	IsAdmin bool `json:"isAdmin"`
	User    User `json:"user"`
}

// CompleteProviderSetupResponse defines model for CompleteProviderSetupResponse.
type CompleteProviderSetupResponse struct {
	// Whether a manual update is required to the Granted Approvals deployment configuration (`granted-deployment.yml`) to activate the provider.
	DeploymentConfigUpdateRequired bool `json:"deploymentConfigUpdateRequired"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error string `json:"error"`
}

// IdentityConfigurationResponse defines model for IdentityConfigurationResponse.
type IdentityConfigurationResponse struct {
	AdministratorGroupId string `json:"administratorGroupId"`
	IdentityProvider     string `json:"identityProvider"`
}

// ListAccessRuleApproversResponse defines model for ListAccessRuleApproversResponse.
type ListAccessRuleApproversResponse struct {
	Next  *string  `json:"next"`
	Users []string `json:"users"`
}

// ListAccessRulesDetailResponse defines model for ListAccessRulesDetailResponse.
type ListAccessRulesDetailResponse struct {
	AccessRules []AccessRuleDetail `json:"accessRules"`
	Next        *string            `json:"next"`
}

// ListAccessRulesResponse defines model for ListAccessRulesResponse.
type ListAccessRulesResponse struct {
	AccessRules []AccessRule `json:"accessRules"`
	Next        *string      `json:"next"`
}

// ListGroupsResponse defines model for ListGroupsResponse.
type ListGroupsResponse struct {
	Groups []Group `json:"groups"`
	Next   *string `json:"next"`
}

// ListProviderSetupsResponse defines model for ListProviderSetupsResponse.
type ListProviderSetupsResponse struct {
	ProviderSetups []ProviderSetup `json:"providerSetups"`
}

// ListRequestEventsResponse defines model for ListRequestEventsResponse.
type ListRequestEventsResponse struct {
	Events []RequestEvent `json:"events"`
	Next   *string        `json:"next"`
}

// ListRequestsResponse defines model for ListRequestsResponse.
type ListRequestsResponse struct {
	Next     *string   `json:"next"`
	Requests []Request `json:"requests"`
}

// ListUserResponse defines model for ListUserResponse.
type ListUserResponse struct {
	Next  *string `json:"next"`
	Users []User  `json:"users"`
}

// A provider in the process of being set up through the guided setup workflow in Granted. These providers are **not** yet active.
type ProviderSetupResponse = ProviderSetup

// ReviewResponse defines model for ReviewResponse.
type ReviewResponse struct {
	// A request to access something made by an end user in Granted.
	Request *Request `json:"request,omitempty"`
}

// CreateAccessRuleRequest defines model for CreateAccessRuleRequest.
type CreateAccessRuleRequest struct {
	// Approver config for access rules
	Approval    ApproverConfig `json:"approval"`
	Description string         `json:"description"`

	// The group IDs that the access rule applies to.
	Groups []string `json:"groups"`
	Name   string   `json:"name"`

	// a request body for creating a Access Rule Target
	Target CreateAccessRuleTarget `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`
}

// CreateGroupRequest defines model for CreateGroupRequest.
type CreateGroupRequest struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
}

// CreateProviderSetupRequest defines model for CreateProviderSetupRequest.
type CreateProviderSetupRequest struct {
	// The type of the provider to set up.
	ProviderType string `json:"providerType"`
}

// CreateRequestRequest defines model for CreateRequestRequest.
type CreateRequestRequest struct {
	AccessRuleId string             `json:"accessRuleId"`
	Reason       *string            `json:"reason,omitempty"`
	Timing       RequestTiming      `json:"timing"`
	With         *CreateRequestWith `json:"with,omitempty"`
}

// CreateUserRequest defines model for CreateUserRequest.
type CreateUserRequest struct {
	Email     openapi_types.Email `json:"email"`
	FirstName string              `json:"firstName"`
	IsAdmin   bool                `json:"isAdmin"`
	LastName  string              `json:"lastName"`
}

// ProviderSetupStepCompleteRequest defines model for ProviderSetupStepCompleteRequest.
type ProviderSetupStepCompleteRequest struct {
	// Whether the step is complete or not.
	Complete bool `json:"complete"`

	// The config values entered by the user which correspond to the setup step.
	ConfigValues map[string]string `json:"configValues"`
}

// ReviewRequest defines model for ReviewRequest.
type ReviewRequest struct {
	Comment *string `json:"comment,omitempty"`

	// A decision made on an Access Request.
	Decision       ReviewDecision `json:"decision"`
	OverrideTiming *RequestTiming `json:"overrideTiming,omitempty"`
}

// AccessRuleLookupParams defines parameters for AccessRuleLookup.
type AccessRuleLookupParams struct {
	// the provider type i.e. commonfate/aws-sso. type should be encoded i.e.  backslash -> %2
	Type *AccessRuleLookupParamsType `form:"type,omitempty" json:"type,omitempty"`

	// the permissionSetArn label, typically resembles a role name i.e. AdminstratorAccess
	PermissionSetArnLabel *string `form:"permissionSetArn.label,omitempty" json:"permissionSetArn.label,omitempty"`

	// the aws account id
	AccountId *string `form:"accountId,omitempty" json:"accountId,omitempty"`
}

// AccessRuleLookupParamsType defines parameters for AccessRuleLookup.
type AccessRuleLookupParamsType string

// AdminListAccessRulesParams defines parameters for AdminListAccessRules.
type AdminListAccessRulesParams struct {
	// Filter Access Rules by a particular status.
	Status *AdminListAccessRulesParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// AdminListAccessRulesParamsStatus defines parameters for AdminListAccessRules.
type AdminListAccessRulesParamsStatus string

// GetGroupsParams defines parameters for GetGroups.
type GetGroupsParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// ListProviderArgOptionsParams defines parameters for ListProviderArgOptions.
type ListProviderArgOptionsParams struct {
	// invalidate the cache and refresh the provider's options.
	Refresh *bool `form:"refresh,omitempty" json:"refresh,omitempty"`
}

// AdminListRequestsParams defines parameters for AdminListRequests.
type AdminListRequestsParams struct {
	// omit this param to view all results
	Status *AdminListRequestsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// AdminListRequestsParamsStatus defines parameters for AdminListRequests.
type AdminListRequestsParamsStatus string

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody struct {
	Groups []string `json:"groups"`
}

// UserListRequestsParams defines parameters for UserListRequests.
type UserListRequestsParams struct {
	// omit this param to view all results
	Status *UserListRequestsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// show requests that the user is a reviewer for, rather than requests that the user has made themselves
	Reviewer *bool `form:"reviewer,omitempty" json:"reviewer,omitempty"`

	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// UserListRequestsParamsStatus defines parameters for UserListRequests.
type UserListRequestsParamsStatus string

// UserListRequestsPastParams defines parameters for UserListRequestsPast.
type UserListRequestsPastParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// UserListRequestsUpcomingParams defines parameters for UserListRequestsUpcoming.
type UserListRequestsUpcomingParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// AdminCreateAccessRuleJSONRequestBody defines body for AdminCreateAccessRule for application/json ContentType.
type AdminCreateAccessRuleJSONRequestBody CreateAccessRuleRequest

// AdminUpdateAccessRuleJSONRequestBody defines body for AdminUpdateAccessRule for application/json ContentType.
type AdminUpdateAccessRuleJSONRequestBody CreateAccessRuleRequest

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupRequest

// CreateProvidersetupJSONRequestBody defines body for CreateProvidersetup for application/json ContentType.
type CreateProvidersetupJSONRequestBody CreateProviderSetupRequest

// SubmitProvidersetupStepJSONRequestBody defines body for SubmitProvidersetupStep for application/json ContentType.
type SubmitProvidersetupStepJSONRequestBody ProviderSetupStepCompleteRequest

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserRequest

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody UpdateUserJSONBody

// UserCreateRequestJSONRequestBody defines body for UserCreateRequest for application/json ContentType.
type UserCreateRequestJSONRequestBody CreateRequestRequest

// ReviewRequestJSONRequestBody defines body for ReviewRequest for application/json ContentType.
type ReviewRequestJSONRequestBody ReviewRequest

// Getter for additional properties for AccessRuleTargetDetail_With. Returns the specified
// element and whether it was found
func (a AccessRuleTargetDetail_With) Get(fieldName string) (value AccessRuleTargetDetailArguments, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AccessRuleTargetDetail_With
func (a *AccessRuleTargetDetail_With) Set(fieldName string, value AccessRuleTargetDetailArguments) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AccessRuleTargetDetailArguments)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AccessRuleTargetDetail_With to handle AdditionalProperties
func (a *AccessRuleTargetDetail_With) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AccessRuleTargetDetailArguments)
		for fieldName, fieldBuf := range object {
			var fieldVal AccessRuleTargetDetailArguments
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AccessRuleTargetDetail_With to handle AdditionalProperties
func (a AccessRuleTargetDetail_With) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AccessRuleTargetDetailArguments_Groupings. Returns the specified
// element and whether it was found
func (a AccessRuleTargetDetailArguments_Groupings) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AccessRuleTargetDetailArguments_Groupings
func (a *AccessRuleTargetDetailArguments_Groupings) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a *AccessRuleTargetDetailArguments_Groupings) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a AccessRuleTargetDetailArguments_Groupings) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateAccessRuleTarget_With. Returns the specified
// element and whether it was found
func (a CreateAccessRuleTarget_With) Get(fieldName string) (value AccessRuleTargetDetailArguments, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateAccessRuleTarget_With
func (a *CreateAccessRuleTarget_With) Set(fieldName string, value AccessRuleTargetDetailArguments) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AccessRuleTargetDetailArguments)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateAccessRuleTarget_With to handle AdditionalProperties
func (a *CreateAccessRuleTarget_With) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AccessRuleTargetDetailArguments)
		for fieldName, fieldBuf := range object {
			var fieldVal AccessRuleTargetDetailArguments
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateAccessRuleTarget_With to handle AdditionalProperties
func (a CreateAccessRuleTarget_With) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateRequestWith. Returns the specified
// element and whether it was found
func (a CreateRequestWith) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateRequestWith
func (a *CreateRequestWith) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateRequestWith to handle AdditionalProperties
func (a *CreateRequestWith) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateRequestWith to handle AdditionalProperties
func (a CreateRequestWith) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RequestAccessRuleTarget_Arguments. Returns the specified
// element and whether it was found
func (a RequestAccessRuleTarget_Arguments) Get(fieldName string) (value RequestArgument, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RequestAccessRuleTarget_Arguments
func (a *RequestAccessRuleTarget_Arguments) Set(fieldName string, value RequestArgument) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]RequestArgument)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RequestAccessRuleTarget_Arguments to handle AdditionalProperties
func (a *RequestAccessRuleTarget_Arguments) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]RequestArgument)
		for fieldName, fieldBuf := range object {
			var fieldVal RequestArgument
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RequestAccessRuleTarget_Arguments to handle AdditionalProperties
func (a RequestAccessRuleTarget_Arguments) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RequestDetail_Arguments. Returns the specified
// element and whether it was found
func (a RequestDetail_Arguments) Get(fieldName string) (value With, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RequestDetail_Arguments
func (a *RequestDetail_Arguments) Set(fieldName string, value With) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]With)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RequestDetail_Arguments to handle AdditionalProperties
func (a *RequestDetail_Arguments) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]With)
		for fieldName, fieldBuf := range object {
			var fieldVal With
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RequestDetail_Arguments to handle AdditionalProperties
func (a RequestDetail_Arguments) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List Access Rules
	// (GET /api/v1/access-rules)
	ListUserAccessRules(w http.ResponseWriter, r *http.Request)
	// Lookup an access rule based on the target
	// (GET /api/v1/access-rules/lookup)
	AccessRuleLookup(w http.ResponseWriter, r *http.Request, params AccessRuleLookupParams)
	// Get Access Rule
	// (GET /api/v1/access-rules/{ruleId})
	UserGetAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// List Access Rule approvers
	// (GET /api/v1/access-rules/{ruleId}/approvers)
	UserGetAccessRuleApprovers(w http.ResponseWriter, r *http.Request, ruleId string)
	// List Access Rules
	// (GET /api/v1/admin/access-rules)
	AdminListAccessRules(w http.ResponseWriter, r *http.Request, params AdminListAccessRulesParams)
	// Create Access Rule
	// (POST /api/v1/admin/access-rules)
	AdminCreateAccessRule(w http.ResponseWriter, r *http.Request)
	// Get Access Rule
	// (GET /api/v1/admin/access-rules/{ruleId})
	AdminGetAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Update Access Rule
	// (PUT /api/v1/admin/access-rules/{ruleId})
	AdminUpdateAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Archive Access Rule
	// (POST /api/v1/admin/access-rules/{ruleId}/archive)
	AdminArchiveAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Get Access Rule version history
	// (GET /api/v1/admin/access-rules/{ruleId}/versions)
	AdminGetAccessRuleVersions(w http.ResponseWriter, r *http.Request, ruleId string)
	// Get Access Rule Version
	// (GET /api/v1/admin/access-rules/{ruleId}/versions/{version})
	AdminGetAccessRuleVersion(w http.ResponseWriter, r *http.Request, ruleId string, version string)
	// List groups
	// (GET /api/v1/admin/groups)
	GetGroups(w http.ResponseWriter, r *http.Request, params GetGroupsParams)
	// Create Group
	// (POST /api/v1/admin/groups)
	CreateGroup(w http.ResponseWriter, r *http.Request)
	// Get Group Details
	// (GET /api/v1/admin/groups/{groupId})
	GetGroup(w http.ResponseWriter, r *http.Request, groupId string)
	// Get identity configuration
	// (GET /api/v1/admin/identity)
	IdentityConfiguration(w http.ResponseWriter, r *http.Request)
	// Sync Identity
	// (POST /api/v1/admin/identity/sync)
	IdentitySync(w http.ResponseWriter, r *http.Request)
	// List providers
	// (GET /api/v1/admin/providers)
	ListProviders(w http.ResponseWriter, r *http.Request)
	// List providers
	// (GET /api/v1/admin/providers/{providerId})
	GetProvider(w http.ResponseWriter, r *http.Request, providerId string)
	// Get provider arg schema
	// (GET /api/v1/admin/providers/{providerId}/args)
	GetProviderArgs(w http.ResponseWriter, r *http.Request, providerId string)
	// List provider arg options
	// (GET /api/v1/admin/providers/{providerId}/args/{argId}/options)
	ListProviderArgOptions(w http.ResponseWriter, r *http.Request, providerId string, argId string, params ListProviderArgOptionsParams)
	// List the provider setups in progress
	// (GET /api/v1/admin/providersetups)
	ListProvidersetups(w http.ResponseWriter, r *http.Request)
	// Begin the setup process for a new Access Provider
	// (POST /api/v1/admin/providersetups)
	CreateProvidersetup(w http.ResponseWriter, r *http.Request)
	// Delete an in-progress provider setup
	// (DELETE /api/v1/admin/providersetups/{providersetupId})
	DeleteProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Get an in-progress provider setup
	// (GET /api/v1/admin/providersetups/{providersetupId})
	GetProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Complete a ProviderSetup
	// (POST /api/v1/admin/providersetups/{providersetupId}/complete)
	CompleteProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Get the setup instructions for an Access Provider
	// (GET /api/v1/admin/providersetups/{providersetupId}/instructions)
	GetProvidersetupInstructions(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Update the completion status for a Provider setup step
	// (PUT /api/v1/admin/providersetups/{providersetupId}/steps/{stepIndex}/complete)
	SubmitProvidersetupStep(w http.ResponseWriter, r *http.Request, providersetupId string, stepIndex int)
	// Validate the configuration for a Provider Setup
	// (POST /api/v1/admin/providersetups/{providersetupId}/validate)
	ValidateProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Your GET endpoint
	// (GET /api/v1/admin/requests)
	AdminListRequests(w http.ResponseWriter, r *http.Request, params AdminListRequestsParams)
	// Get a request
	// (GET /api/v1/admin/requests/{requestId})
	AdminGetRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// Returns a list of users
	// (GET /api/v1/admin/users)
	GetUsers(w http.ResponseWriter, r *http.Request, params GetUsersParams)
	// Create User
	// (POST /api/v1/admin/users)
	CreateUser(w http.ResponseWriter, r *http.Request)
	// Update User
	// (POST /api/v1/admin/users/{userId})
	UpdateUser(w http.ResponseWriter, r *http.Request, userId string)
	// List my requests
	// (GET /api/v1/requests)
	UserListRequests(w http.ResponseWriter, r *http.Request, params UserListRequestsParams)
	// Create a request
	// (POST /api/v1/requests)
	UserCreateRequest(w http.ResponseWriter, r *http.Request)
	// Your GET endpoint
	// (GET /api/v1/requests/past)
	UserListRequestsPast(w http.ResponseWriter, r *http.Request, params UserListRequestsPastParams)
	// Your GET endpoint
	// (GET /api/v1/requests/upcoming)
	UserListRequestsUpcoming(w http.ResponseWriter, r *http.Request, params UserListRequestsUpcomingParams)
	// Get a request
	// (GET /api/v1/requests/{requestId})
	UserGetRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// Get Access Instructions
	// (GET /api/v1/requests/{requestId}/access-instructions)
	GetAccessInstructions(w http.ResponseWriter, r *http.Request, requestId string)
	// Get Access Token
	// (GET /api/v1/requests/{requestId}/access-token)
	GetAccessToken(w http.ResponseWriter, r *http.Request, requestId string)
	// Cancel a request
	// (POST /api/v1/requests/{requestId}/cancel)
	CancelRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// List request events
	// (GET /api/v1/requests/{requestId}/events)
	ListRequestEvents(w http.ResponseWriter, r *http.Request, requestId string)
	// Review a request
	// (POST /api/v1/requests/{requestId}/review)
	ReviewRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// Revoke an active request
	// (POST /api/v1/requests/{requestid}/revoke)
	RevokeRequest(w http.ResponseWriter, r *http.Request, requestid string)
	// Get details for the current user
	// (GET /api/v1/users/me)
	GetMe(w http.ResponseWriter, r *http.Request)
	// Get a user
	// (GET /api/v1/users/{userId})
	GetUser(w http.ResponseWriter, r *http.Request, userId string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// ListUserAccessRules operation middleware
func (siw *ServerInterfaceWrapper) ListUserAccessRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserAccessRules(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AccessRuleLookup operation middleware
func (siw *ServerInterfaceWrapper) AccessRuleLookup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AccessRuleLookupParams

	// ------------- Optional query parameter "type" -------------
	if paramValue := r.URL.Query().Get("type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	// ------------- Optional query parameter "permissionSetArn.label" -------------
	if paramValue := r.URL.Query().Get("permissionSetArn.label"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "permissionSetArn.label", r.URL.Query(), &params.PermissionSetArnLabel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "permissionSetArn.label", Err: err})
		return
	}

	// ------------- Optional query parameter "accountId" -------------
	if paramValue := r.URL.Query().Get("accountId"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "accountId", r.URL.Query(), &params.AccountId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccessRuleLookup(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetAccessRule operation middleware
func (siw *ServerInterfaceWrapper) UserGetAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetAccessRuleApprovers operation middleware
func (siw *ServerInterfaceWrapper) UserGetAccessRuleApprovers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetAccessRuleApprovers(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminListAccessRules operation middleware
func (siw *ServerInterfaceWrapper) AdminListAccessRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminListAccessRulesParams

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminListAccessRules(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminCreateAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminCreateAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminCreateAccessRule(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminGetAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminUpdateAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminUpdateAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminUpdateAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminArchiveAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminArchiveAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminArchiveAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetAccessRuleVersions operation middleware
func (siw *ServerInterfaceWrapper) AdminGetAccessRuleVersions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetAccessRuleVersions(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetAccessRuleVersion operation middleware
func (siw *ServerInterfaceWrapper) AdminGetAccessRuleVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameter("simple", false, "version", chi.URLParam(r, "version"), &version)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetAccessRuleVersion(w, r, ruleId, version)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGroups operation middleware
func (siw *ServerInterfaceWrapper) GetGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGroupsParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroups(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateGroup operation middleware
func (siw *ServerInterfaceWrapper) CreateGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGroup(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGroup operation middleware
func (siw *ServerInterfaceWrapper) GetGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroup(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// IdentityConfiguration operation middleware
func (siw *ServerInterfaceWrapper) IdentityConfiguration(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.IdentityConfiguration(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// IdentitySync operation middleware
func (siw *ServerInterfaceWrapper) IdentitySync(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.IdentitySync(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListProviders operation middleware
func (siw *ServerInterfaceWrapper) ListProviders(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProviders(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProvider operation middleware
func (siw *ServerInterfaceWrapper) GetProvider(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providerId" -------------
	var providerId string

	err = runtime.BindStyledParameter("simple", false, "providerId", chi.URLParam(r, "providerId"), &providerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providerId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProvider(w, r, providerId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProviderArgs operation middleware
func (siw *ServerInterfaceWrapper) GetProviderArgs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providerId" -------------
	var providerId string

	err = runtime.BindStyledParameter("simple", false, "providerId", chi.URLParam(r, "providerId"), &providerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providerId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProviderArgs(w, r, providerId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListProviderArgOptions operation middleware
func (siw *ServerInterfaceWrapper) ListProviderArgOptions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providerId" -------------
	var providerId string

	err = runtime.BindStyledParameter("simple", false, "providerId", chi.URLParam(r, "providerId"), &providerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providerId", Err: err})
		return
	}

	// ------------- Path parameter "argId" -------------
	var argId string

	err = runtime.BindStyledParameter("simple", false, "argId", chi.URLParam(r, "argId"), &argId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "argId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProviderArgOptionsParams

	// ------------- Optional query parameter "refresh" -------------
	if paramValue := r.URL.Query().Get("refresh"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "refresh", r.URL.Query(), &params.Refresh)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "refresh", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProviderArgOptions(w, r, providerId, argId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListProvidersetups operation middleware
func (siw *ServerInterfaceWrapper) ListProvidersetups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProvidersetups(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) CreateProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProvidersetup(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) DeleteProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) GetProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CompleteProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) CompleteProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CompleteProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProvidersetupInstructions operation middleware
func (siw *ServerInterfaceWrapper) GetProvidersetupInstructions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProvidersetupInstructions(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SubmitProvidersetupStep operation middleware
func (siw *ServerInterfaceWrapper) SubmitProvidersetupStep(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	// ------------- Path parameter "stepIndex" -------------
	var stepIndex int

	err = runtime.BindStyledParameter("simple", false, "stepIndex", chi.URLParam(r, "stepIndex"), &stepIndex)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "stepIndex", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SubmitProvidersetupStep(w, r, providersetupId, stepIndex)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ValidateProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) ValidateProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ValidateProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminListRequests operation middleware
func (siw *ServerInterfaceWrapper) AdminListRequests(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminListRequestsParams

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminListRequests(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetRequest operation middleware
func (siw *ServerInterfaceWrapper) AdminGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUsers operation middleware
func (siw *ServerInterfaceWrapper) GetUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUsers(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateUser operation middleware
func (siw *ServerInterfaceWrapper) CreateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUser(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateUser operation middleware
func (siw *ServerInterfaceWrapper) UpdateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserListRequests operation middleware
func (siw *ServerInterfaceWrapper) UserListRequests(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListRequestsParams

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "reviewer" -------------
	if paramValue := r.URL.Query().Get("reviewer"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "reviewer", r.URL.Query(), &params.Reviewer)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "reviewer", Err: err})
		return
	}

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListRequests(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserCreateRequest operation middleware
func (siw *ServerInterfaceWrapper) UserCreateRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserCreateRequest(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserListRequestsPast operation middleware
func (siw *ServerInterfaceWrapper) UserListRequestsPast(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListRequestsPastParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListRequestsPast(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserListRequestsUpcoming operation middleware
func (siw *ServerInterfaceWrapper) UserListRequestsUpcoming(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListRequestsUpcomingParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListRequestsUpcoming(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetRequest operation middleware
func (siw *ServerInterfaceWrapper) UserGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetAccessInstructions operation middleware
func (siw *ServerInterfaceWrapper) GetAccessInstructions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAccessInstructions(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetAccessToken operation middleware
func (siw *ServerInterfaceWrapper) GetAccessToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAccessToken(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CancelRequest operation middleware
func (siw *ServerInterfaceWrapper) CancelRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CancelRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListRequestEvents operation middleware
func (siw *ServerInterfaceWrapper) ListRequestEvents(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRequestEvents(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ReviewRequest operation middleware
func (siw *ServerInterfaceWrapper) ReviewRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReviewRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RevokeRequest operation middleware
func (siw *ServerInterfaceWrapper) RevokeRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestid" -------------
	var requestid string

	err = runtime.BindStyledParameter("simple", false, "requestid", chi.URLParam(r, "requestid"), &requestid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestid", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RevokeRequest(w, r, requestid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetMe operation middleware
func (siw *ServerInterfaceWrapper) GetMe(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMe(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUser operation middleware
func (siw *ServerInterfaceWrapper) GetUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules", wrapper.ListUserAccessRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules/lookup", wrapper.AccessRuleLookup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules/{ruleId}", wrapper.UserGetAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules/{ruleId}/approvers", wrapper.UserGetAccessRuleApprovers)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules", wrapper.AdminListAccessRules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/access-rules", wrapper.AdminCreateAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}", wrapper.AdminGetAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}", wrapper.AdminUpdateAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}/archive", wrapper.AdminArchiveAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}/versions", wrapper.AdminGetAccessRuleVersions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}/versions/{version}", wrapper.AdminGetAccessRuleVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/groups", wrapper.GetGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/groups", wrapper.CreateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/groups/{groupId}", wrapper.GetGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/identity", wrapper.IdentityConfiguration)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/identity/sync", wrapper.IdentitySync)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers", wrapper.ListProviders)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers/{providerId}", wrapper.GetProvider)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers/{providerId}/args", wrapper.GetProviderArgs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers/{providerId}/args/{argId}/options", wrapper.ListProviderArgOptions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providersetups", wrapper.ListProvidersetups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/providersetups", wrapper.CreateProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}", wrapper.DeleteProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}", wrapper.GetProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/complete", wrapper.CompleteProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/instructions", wrapper.GetProvidersetupInstructions)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/steps/{stepIndex}/complete", wrapper.SubmitProvidersetupStep)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/validate", wrapper.ValidateProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/requests", wrapper.AdminListRequests)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/requests/{requestId}", wrapper.AdminGetRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/users", wrapper.GetUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/users", wrapper.CreateUser)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/users/{userId}", wrapper.UpdateUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests", wrapper.UserListRequests)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests", wrapper.UserCreateRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/past", wrapper.UserListRequestsPast)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/upcoming", wrapper.UserListRequestsUpcoming)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}", wrapper.UserGetRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}/access-instructions", wrapper.GetAccessInstructions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}/access-token", wrapper.GetAccessToken)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests/{requestId}/cancel", wrapper.CancelRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}/events", wrapper.ListRequestEvents)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests/{requestId}/review", wrapper.ReviewRequest)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests/{requestid}/revoke", wrapper.RevokeRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/users/me", wrapper.GetMe)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/users/{userId}", wrapper.GetUser)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	pathPrefix := path.Dir(pathToFile)

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(pathPrefix, "./accesshandler/openapi.yml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
