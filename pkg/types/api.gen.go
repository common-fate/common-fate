// Package types provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package types

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	externalRef0 "github.com/common-fate/granted-approvals/accesshandler/pkg/types"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// Defines values for AccessRuleStatus.
const (
	AccessRuleStatusACTIVE   AccessRuleStatus = "ACTIVE"
	AccessRuleStatusARCHIVED AccessRuleStatus = "ARCHIVED"
)

// Defines values for AccessRuleTargetDetailArgumentsFormElement.
const (
	INPUT       AccessRuleTargetDetailArgumentsFormElement = "INPUT"
	MULTISELECT AccessRuleTargetDetailArgumentsFormElement = "MULTISELECT"
	SELECT      AccessRuleTargetDetailArgumentsFormElement = "SELECT"
)

// Defines values for ApprovalMethod.
const (
	AUTOMATIC ApprovalMethod = "AUTOMATIC"
	REVIEWED  ApprovalMethod = "REVIEWED"
)

// Defines values for GrantStatus.
const (
	GrantStatusACTIVE  GrantStatus = "ACTIVE"
	GrantStatusERROR   GrantStatus = "ERROR"
	GrantStatusEXPIRED GrantStatus = "EXPIRED"
	GrantStatusPENDING GrantStatus = "PENDING"
	GrantStatusREVOKED GrantStatus = "REVOKED"
)

// Defines values for IdpStatus.
const (
	IdpStatusACTIVE   IdpStatus = "ACTIVE"
	IdpStatusARCHIVED IdpStatus = "ARCHIVED"
)

// Defines values for ProviderSetupStatus.
const (
	COMPLETE                       ProviderSetupStatus = "COMPLETE"
	INITIALCONFIGURATIONINPROGRESS ProviderSetupStatus = "INITIAL_CONFIGURATION_IN_PROGRESS"
	VALIDATING                     ProviderSetupStatus = "VALIDATING"
	VALIDATIONFAILED               ProviderSetupStatus = "VALIDATION_FAILED"
	VALIDATIONSUCEEDED             ProviderSetupStatus = "VALIDATION_SUCEEDED"
)

// Defines values for ProviderSetupDiagnosticLogLevel.
const (
	ProviderSetupDiagnosticLogLevelERROR   ProviderSetupDiagnosticLogLevel = "ERROR"
	ProviderSetupDiagnosticLogLevelINFO    ProviderSetupDiagnosticLogLevel = "INFO"
	ProviderSetupDiagnosticLogLevelWARNING ProviderSetupDiagnosticLogLevel = "WARNING"
)

// Defines values for ProviderSetupValidationStatus.
const (
	ProviderSetupValidationStatusERROR      ProviderSetupValidationStatus = "ERROR"
	ProviderSetupValidationStatusINPROGRESS ProviderSetupValidationStatus = "IN_PROGRESS"
	ProviderSetupValidationStatusPENDING    ProviderSetupValidationStatus = "PENDING"
	ProviderSetupValidationStatusSUCCESS    ProviderSetupValidationStatus = "SUCCESS"
)

// Defines values for RequestEventFromGrantStatus.
const (
	RequestEventFromGrantStatusACTIVE  RequestEventFromGrantStatus = "ACTIVE"
	RequestEventFromGrantStatusERROR   RequestEventFromGrantStatus = "ERROR"
	RequestEventFromGrantStatusEXPIRED RequestEventFromGrantStatus = "EXPIRED"
	RequestEventFromGrantStatusPENDING RequestEventFromGrantStatus = "PENDING"
	RequestEventFromGrantStatusREVOKED RequestEventFromGrantStatus = "REVOKED"
)

// Defines values for RequestEventToGrantStatus.
const (
	RequestEventToGrantStatusACTIVE  RequestEventToGrantStatus = "ACTIVE"
	RequestEventToGrantStatusERROR   RequestEventToGrantStatus = "ERROR"
	RequestEventToGrantStatusEXPIRED RequestEventToGrantStatus = "EXPIRED"
	RequestEventToGrantStatusPENDING RequestEventToGrantStatus = "PENDING"
	RequestEventToGrantStatusREVOKED RequestEventToGrantStatus = "REVOKED"
)

// Defines values for RequestStatus.
const (
	RequestStatusAPPROVED  RequestStatus = "APPROVED"
	RequestStatusCANCELLED RequestStatus = "CANCELLED"
	RequestStatusDECLINED  RequestStatus = "DECLINED"
	RequestStatusPENDING   RequestStatus = "PENDING"
)

// Defines values for ReviewDecision.
const (
	APPROVED ReviewDecision = "APPROVED"
	DECLINED ReviewDecision = "DECLINED"
)

// Access Rule contains information for an end user to make a request for access.
type AccessRule struct {
	Description string `json:"description"`
	ID          string `json:"id"`
	IsCurrent   bool   `json:"isCurrent"`
	Name        string `json:"name"`

	// A target for an access rule
	Target AccessRuleTarget `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`

	// A unique version identifier for the Access Rule. Updating a rule creates a new version.
	// When a rule is updated, it's ID remains consistent.
	Version string `json:"version"`
}

// AccessRuleDetail contains detailed information about a rule and is used in administrative apis.
type AccessRuleDetail struct {
	// Approver config for access rules
	Approval    ApproverConfig `json:"approval"`
	Description string         `json:"description"`

	// The group IDs that the access rule applies to.
	Groups    []string           `json:"groups"`
	ID        string             `json:"id"`
	IsCurrent bool               `json:"isCurrent"`
	Metadata  AccessRuleMetadata `json:"metadata"`
	Name      string             `json:"name"`

	// The status of an Access Rule.
	Status AccessRuleStatus `json:"status"`

	// A detailed target for an access rule
	Target AccessRuleTargetDetail `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`

	// A unique version identifier for the Access Rule. Updating a rule creates a new version.
	// When a rule is updated, it's ID remains consistent.
	Version string `json:"version"`
}

// AccessRuleMetadata defines model for AccessRuleMetadata.
type AccessRuleMetadata struct {
	CreatedAt     time.Time `json:"createdAt"`
	CreatedBy     string    `json:"createdBy"`
	UpdateMessage *string   `json:"updateMessage,omitempty"`
	UpdatedAt     time.Time `json:"updatedAt"`
	UpdatedBy     string    `json:"updatedBy"`
}

// The status of an Access Rule.
type AccessRuleStatus string

// A target for an access rule
type AccessRuleTarget struct {
	// Provider
	Provider Provider `json:"provider"`
}

// A detailed target for an access rule
type AccessRuleTargetDetail struct {
	// Provider
	Provider Provider                    `json:"provider"`
	With     AccessRuleTargetDetail_With `json:"with"`
}

// AccessRuleTargetDetail_With defines model for AccessRuleTargetDetail.With.
type AccessRuleTargetDetail_With struct {
	AdditionalProperties map[string]AccessRuleTargetDetailArguments `json:"-"`
}

// AccessRuleTargetDetailArguments defines model for AccessRuleTargetDetailArguments.
type AccessRuleTargetDetailArguments struct {
	FormElement AccessRuleTargetDetailArgumentsFormElement `json:"formElement"`
	Groupings   AccessRuleTargetDetailArguments_Groupings  `json:"groupings"`
	Values      []string                                   `json:"values"`
}

// AccessRuleTargetDetailArgumentsFormElement defines model for AccessRuleTargetDetailArguments.FormElement.
type AccessRuleTargetDetailArgumentsFormElement string

// AccessRuleTargetDetailArguments_Groupings defines model for AccessRuleTargetDetailArguments.Groupings.
type AccessRuleTargetDetailArguments_Groupings struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// AccessToken defines model for AccessToken.
type AccessToken = string

// Describes whether a request has been approved automatically or from a review
type ApprovalMethod string

// Approver config for access rules
type ApproverConfig struct {
	Groups []string `json:"groups"`

	// The user IDs of the approvers for the request.
	Users []string `json:"users"`
}

// a request body for creating a Access Rule Target
type CreateAccessRuleTarget struct {
	ProviderId string                      `json:"providerId"`
	With       CreateAccessRuleTarget_With `json:"with"`
}

// CreateAccessRuleTarget_With defines model for CreateAccessRuleTarget.With.
type CreateAccessRuleTarget_With struct {
	AdditionalProperties map[string]CreateAccessRuleTargetDetailArguments `json:"-"`
}

// CreateAccessRuleTargetDetailArguments defines model for CreateAccessRuleTargetDetailArguments.
type CreateAccessRuleTargetDetailArguments struct {
	Groupings CreateAccessRuleTargetDetailArguments_Groupings `json:"groupings"`
	Values    []string                                        `json:"values"`
}

// CreateAccessRuleTargetDetailArguments_Groupings defines model for CreateAccessRuleTargetDetailArguments.Groupings.
type CreateAccessRuleTargetDetailArguments_Groupings struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// CreateRequestWith defines model for CreateRequestWith.
type CreateRequestWith struct {
	AdditionalProperties map[string]string `json:"-"`
}

// A temporary assignment of a user to a principal.
type Grant struct {
	// The end time of the grant.
	End time.Time `json:"end"`

	// The ID of the provider to grant access to.
	Provider string `json:"provider"`

	// The start time of the grant.
	Start time.Time `json:"start"`

	// The current state of the grant.
	Status GrantStatus `json:"status"`

	// The email address of the user to grant access to.
	Subject openapi_types.Email `json:"subject"`
}

// The current state of the grant.
type GrantStatus string

// Group defines model for Group.
type Group struct {
	Description string `json:"description"`
	Id          string `json:"id"`
	MemberCount int    `json:"memberCount"`
	Name        string `json:"name"`
}

// IdpStatus defines model for IdpStatus.
type IdpStatus string

// KeyValue defines model for KeyValue.
type KeyValue struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// A matched access rule with option values if they are required for the access rule request
type LookupAccessRule struct {
	// Access Rule contains information for an end user to make a request for access.
	AccessRule AccessRule `json:"accessRule"`

	// If the matched access rule has selectable fields, this array will contain the matched values to be used to prefill the form when requesting
	SelectableWithOptionValues *[]KeyValue `json:"selectableWithOptionValues,omitempty"`
}

// Provider
type Provider struct {
	Id   string `json:"id"`
	Type string `json:"type"`
}

// ProviderConfigField defines model for ProviderConfigField.
type ProviderConfigField struct {
	Description string `json:"description"`
	Id          string `json:"id"`

	// Whether the config value is optional.
	IsOptional bool `json:"isOptional"`

	// Whether or not the config field is a secret (like an API key or a password)
	IsSecret bool   `json:"isSecret"`
	Name     string `json:"name"`

	// the path to where the secret will be stored, in a secrets manager like AWS SSM Parameter Store.
	SecretPath *string `json:"secretPath,omitempty"`
}

// ProviderConfigValue defines model for ProviderConfigValue.
type ProviderConfigValue struct {
	// The ID of the config field.
	Id string `json:"id"`

	// The value entered by the user.
	Value string `json:"value"`
}

// A provider in the process of being set up through the guided setup workflow in Granted. These providers are **not** yet active.
type ProviderSetup struct {
	ConfigValidation []externalRef0.ProviderConfigValidation `json:"configValidation"`

	// The current configuration values.
	ConfigValues map[string]string `json:"configValues"`

	// A unique ID for the provider setup. This is a random KSUID to avoid potential conflicts with user-specified provider IDs in the `granted-deployment.yml` file.
	Id string `json:"id"`

	// The status of the setup process.
	Status ProviderSetupStatus `json:"status"`

	// An overview of the steps indicating whether they are complete.
	Steps []ProviderSetupStepOverview `json:"steps"`

	// The type of the Access Provider being set up.
	Type string `json:"type"`

	// The version of the provider.
	Version string `json:"version"`
}

// The status of the setup process.
type ProviderSetupStatus string

// A log entry related to a provider setup validation.
type ProviderSetupDiagnosticLog struct {
	// The log level.
	Level ProviderSetupDiagnosticLogLevel `json:"level"`

	// The log message.
	Msg string `json:"msg"`
}

// The log level.
type ProviderSetupDiagnosticLogLevel string

// ProviderSetupInstructions defines model for ProviderSetupInstructions.
type ProviderSetupInstructions struct {
	StepDetails []ProviderSetupStepDetails `json:"stepDetails"`
}

// ProviderSetupStepDetails defines model for ProviderSetupStepDetails.
type ProviderSetupStepDetails struct {
	ConfigFields []ProviderConfigField `json:"configFields"`
	Instructions string                `json:"instructions"`
	Title        string                `json:"title"`
}

// Indicates whether a setup step is complete or not.
type ProviderSetupStepOverview struct {
	// Whether the step has been completed.
	Complete bool `json:"complete"`
}

// A validation against the configuration values of the Access Provider.
type ProviderSetupValidation struct {
	// The particular config fields validated, if any.
	FieldsValidated []interface{} `json:"fieldsValidated"`

	// The ID of the validation, such as `list-sso-users`.
	Id   string                        `json:"id"`
	Logs *[]ProviderSetupDiagnosticLog `json:"logs,omitempty"`

	// The status of the validation.
	Status ProviderSetupValidationStatus `json:"status"`
}

// The status of the validation.
type ProviderSetupValidationStatus string

// A request to access something made by an end user in Granted.
type Request struct {
	AccessRuleId      string `json:"accessRuleId"`
	AccessRuleVersion string `json:"accessRuleVersion"`

	// Describes whether a request has been approved automatically or from a review
	ApprovalMethod *ApprovalMethod `json:"approvalMethod,omitempty"`

	// A temporary assignment of a user to a principal.
	Grant       *Grant    `json:"grant,omitempty"`
	ID          string    `json:"id"`
	Reason      *string   `json:"reason,omitempty"`
	RequestedAt time.Time `json:"requestedAt"`
	Requestor   string    `json:"requestor"`

	// The status of an Access Request.
	Status    RequestStatus `json:"status"`
	Timing    RequestTiming `json:"timing"`
	UpdatedAt time.Time     `json:"updatedAt"`
}

// Access Rule contains information for an end user to make a request for access.
type RequestAccessRule struct {
	Description string `json:"description"`
	ID          string `json:"id"`
	IsCurrent   bool   `json:"isCurrent"`
	Name        string `json:"name"`

	// A detailed target for an access rule request
	Target RequestAccessRuleTarget `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`

	// A unique version identifier for the Access Rule. Updating a rule creates a new version.
	// When a rule is updated, it's ID remains consistent.
	Version string `json:"version"`
}

// A detailed target for an access rule request
type RequestAccessRuleTarget struct {
	Arguments RequestAccessRuleTarget_Arguments `json:"arguments"`

	// Provider
	Provider Provider `json:"provider"`
}

// RequestAccessRuleTarget_Arguments defines model for RequestAccessRuleTarget.Arguments.
type RequestAccessRuleTarget_Arguments struct {
	AdditionalProperties map[string]RequestArgument `json:"-"`
}

// RequestArgument defines model for RequestArgument.
type RequestArgument struct {
	Description *string      `json:"description,omitempty"`
	Options     []WithOption `json:"options"`

	// This will be true if a selection is require when creating a request
	RequiresSelection bool   `json:"requiresSelection"`
	Title             string `json:"title"`
}

// A request to access something made by an end user in Granted.
type RequestDetail struct {
	// Access Rule contains information for an end user to make a request for access.
	AccessRule AccessRule `json:"accessRule"`

	// Describes whether a request has been approved automatically or from a review
	ApprovalMethod *ApprovalMethod         `json:"approvalMethod,omitempty"`
	Arguments      RequestDetail_Arguments `json:"arguments"`

	// true if the requesting user is a reviewer of this request.
	CanReview bool `json:"canReview"`

	// A temporary assignment of a user to a principal.
	Grant       *Grant    `json:"grant,omitempty"`
	ID          string    `json:"id"`
	Reason      *string   `json:"reason,omitempty"`
	RequestedAt time.Time `json:"requestedAt"`
	Requestor   string    `json:"requestor"`

	// The status of an Access Request.
	Status    RequestStatus `json:"status"`
	Timing    RequestTiming `json:"timing"`
	UpdatedAt time.Time     `json:"updatedAt"`
}

// RequestDetail_Arguments defines model for RequestDetail.Arguments.
type RequestDetail_Arguments struct {
	AdditionalProperties map[string]With `json:"-"`
}

// RequestEvent defines model for RequestEvent.
type RequestEvent struct {
	Actor     *string   `json:"actor,omitempty"`
	CreatedAt time.Time `json:"createdAt"`

	// The current state of the grant.
	FromGrantStatus *RequestEventFromGrantStatus `json:"fromGrantStatus,omitempty"`

	// The status of an Access Request.
	FromStatus         *RequestStatus `json:"fromStatus,omitempty"`
	FromTiming         *RequestTiming `json:"fromTiming,omitempty"`
	GrantCreated       *bool          `json:"grantCreated,omitempty"`
	GrantFailureReason *string        `json:"grantFailureReason,omitempty"`
	Id                 string         `json:"id"`

	// An event which was recorded relating to the grant.
	RecordedEvent  *map[string]string `json:"recordedEvent,omitempty"`
	RequestCreated *bool              `json:"requestCreated,omitempty"`
	RequestId      string             `json:"requestId"`

	// The current state of the grant.
	ToGrantStatus *RequestEventToGrantStatus `json:"toGrantStatus,omitempty"`

	// The status of an Access Request.
	ToStatus *RequestStatus `json:"toStatus,omitempty"`
	ToTiming *RequestTiming `json:"toTiming,omitempty"`
}

// The current state of the grant.
type RequestEventFromGrantStatus string

// The current state of the grant.
type RequestEventToGrantStatus string

// The status of an Access Request.
type RequestStatus string

// RequestTiming defines model for RequestTiming.
type RequestTiming struct {
	DurationSeconds int `json:"durationSeconds"`

	// iso8601 timestamp in UTC timezone
	StartTime *time.Time `json:"startTime,omitempty"`
}

// A decision made on an Access Request.
type ReviewDecision string

// Time configuration for an Access Rule.
type TimeConstraints struct {
	// The maximum duration in seconds the access is allowed for.
	MaxDurationSeconds int `json:"maxDurationSeconds"`
}

// User defines model for User.
type User struct {
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	Groups    []string  `json:"groups"`
	Id        string    `json:"id"`
	LastName  string    `json:"lastName"`
	Picture   string    `json:"picture"`
	Status    IdpStatus `json:"status"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// With defines model for With.
type With struct {
	FieldDescription  *string `json:"fieldDescription,omitempty"`
	Label             string  `json:"label"`
	OptionDescription *string `json:"optionDescription,omitempty"`
	Title             string  `json:"title"`
	Value             string  `json:"value"`
}

// WithOption defines model for WithOption.
type WithOption struct {
	Description *string `json:"description,omitempty"`
	Label       string  `json:"label"`
	Valid       bool    `json:"valid"`
	Value       string  `json:"value"`
}

// AuthUserResponse defines model for AuthUserResponse.
type AuthUserResponse struct {
	// Whether the user is an administrator of Granted.
	IsAdmin bool `json:"isAdmin"`
	User    User `json:"user"`
}

// CompleteProviderSetupResponse defines model for CompleteProviderSetupResponse.
type CompleteProviderSetupResponse struct {
	// Whether a manual update is required to the Granted Approvals deployment configuration (`granted-deployment.yml`) to activate the provider.
	DeploymentConfigUpdateRequired bool `json:"deploymentConfigUpdateRequired"`
}

// DeploymentVersionResponse defines model for DeploymentVersionResponse.
type DeploymentVersionResponse struct {
	// The deployment version. Will be a semver, such as "v0.9.0" for official releases, or "dev+GIT_HASH" for pre-release builds.
	Version string `json:"version"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error string `json:"error"`
}

// IdentityConfigurationResponse defines model for IdentityConfigurationResponse.
type IdentityConfigurationResponse struct {
	AdministratorGroupId string `json:"administratorGroupId"`
	IdentityProvider     string `json:"identityProvider"`
}

// ListAccessRuleApproversResponse defines model for ListAccessRuleApproversResponse.
type ListAccessRuleApproversResponse struct {
	Next  *string  `json:"next"`
	Users []string `json:"users"`
}

// ListAccessRulesDetailResponse defines model for ListAccessRulesDetailResponse.
type ListAccessRulesDetailResponse struct {
	AccessRules []AccessRuleDetail `json:"accessRules"`
	Next        *string            `json:"next"`
}

// ListAccessRulesResponse defines model for ListAccessRulesResponse.
type ListAccessRulesResponse struct {
	AccessRules []AccessRule `json:"accessRules"`
	Next        *string      `json:"next"`
}

// ListGroupsResponse defines model for ListGroupsResponse.
type ListGroupsResponse struct {
	Groups []Group `json:"groups"`
	Next   *string `json:"next"`
}

// ListProviderSetupsResponse defines model for ListProviderSetupsResponse.
type ListProviderSetupsResponse struct {
	ProviderSetups []ProviderSetup `json:"providerSetups"`
}

// ListRequestEventsResponse defines model for ListRequestEventsResponse.
type ListRequestEventsResponse struct {
	Events []RequestEvent `json:"events"`
	Next   *string        `json:"next"`
}

// ListRequestsResponse defines model for ListRequestsResponse.
type ListRequestsResponse struct {
	Next     *string   `json:"next"`
	Requests []Request `json:"requests"`
}

// ListUserResponse defines model for ListUserResponse.
type ListUserResponse struct {
	Next  *string `json:"next"`
	Users []User  `json:"users"`
}

// A provider in the process of being set up through the guided setup workflow in Granted. These providers are **not** yet active.
type ProviderSetupResponse = ProviderSetup

// ReviewResponse defines model for ReviewResponse.
type ReviewResponse struct {
	// A request to access something made by an end user in Granted.
	Request *Request `json:"request,omitempty"`
}

// CreateAccessRuleRequest defines model for CreateAccessRuleRequest.
type CreateAccessRuleRequest struct {
	// Approver config for access rules
	Approval    ApproverConfig `json:"approval"`
	Description string         `json:"description"`

	// The group IDs that the access rule applies to.
	Groups []string `json:"groups"`
	Name   string   `json:"name"`

	// a request body for creating a Access Rule Target
	Target CreateAccessRuleTarget `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`
}

// CreateGroupRequest defines model for CreateGroupRequest.
type CreateGroupRequest struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
}

// CreateProviderSetupRequest defines model for CreateProviderSetupRequest.
type CreateProviderSetupRequest struct {
	// The type of the provider to set up.
	ProviderType string `json:"providerType"`
}

// CreateRequestRequest defines model for CreateRequestRequest.
type CreateRequestRequest struct {
	AccessRuleId string             `json:"accessRuleId"`
	Reason       *string            `json:"reason,omitempty"`
	Timing       RequestTiming      `json:"timing"`
	With         *CreateRequestWith `json:"with,omitempty"`
}

// CreateUserRequest defines model for CreateUserRequest.
type CreateUserRequest struct {
	Email     openapi_types.Email `json:"email"`
	FirstName string              `json:"firstName"`
	IsAdmin   bool                `json:"isAdmin"`
	LastName  string              `json:"lastName"`
}

// ProviderSetupStepCompleteRequest defines model for ProviderSetupStepCompleteRequest.
type ProviderSetupStepCompleteRequest struct {
	// Whether the step is complete or not.
	Complete bool `json:"complete"`

	// The config values entered by the user which correspond to the setup step.
	ConfigValues map[string]string `json:"configValues"`
}

// ReviewRequest defines model for ReviewRequest.
type ReviewRequest struct {
	Comment *string `json:"comment,omitempty"`

	// A decision made on an Access Request.
	Decision       ReviewDecision `json:"decision"`
	OverrideTiming *RequestTiming `json:"overrideTiming,omitempty"`
}

// AccessRuleLookupParams defines parameters for AccessRuleLookup.
type AccessRuleLookupParams struct {
	// the provider type i.e. commonfate/aws-sso. type should be encoded i.e.  backslash -> %2
	Type *AccessRuleLookupParamsType `form:"type,omitempty" json:"type,omitempty"`

	// the permissionSetArn label, typically resembles a role name i.e. AdminstratorAccess
	PermissionSetArnLabel *string `form:"permissionSetArn.label,omitempty" json:"permissionSetArn.label,omitempty"`

	// the aws account id
	AccountId *string `form:"accountId,omitempty" json:"accountId,omitempty"`
}

// AccessRuleLookupParamsType defines parameters for AccessRuleLookup.
type AccessRuleLookupParamsType string

// AdminListAccessRulesParams defines parameters for AdminListAccessRules.
type AdminListAccessRulesParams struct {
	// Filter Access Rules by a particular status.
	Status *AdminListAccessRulesParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// AdminListAccessRulesParamsStatus defines parameters for AdminListAccessRules.
type AdminListAccessRulesParamsStatus string

// GetGroupsParams defines parameters for GetGroups.
type GetGroupsParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// ListProviderArgOptionsParams defines parameters for ListProviderArgOptions.
type ListProviderArgOptionsParams struct {
	// invalidate the cache and refresh the provider's options.
	Refresh *bool `form:"refresh,omitempty" json:"refresh,omitempty"`
}

// AdminListRequestsParams defines parameters for AdminListRequests.
type AdminListRequestsParams struct {
	// omit this param to view all results
	Status *AdminListRequestsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// AdminListRequestsParamsStatus defines parameters for AdminListRequests.
type AdminListRequestsParamsStatus string

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody struct {
	Groups []string `json:"groups"`
}

// UserListRequestsParams defines parameters for UserListRequests.
type UserListRequestsParams struct {
	// omit this param to view all results
	Status *UserListRequestsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// show requests that the user is a reviewer for, rather than requests that the user has made themselves
	Reviewer *bool `form:"reviewer,omitempty" json:"reviewer,omitempty"`

	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// UserListRequestsParamsStatus defines parameters for UserListRequests.
type UserListRequestsParamsStatus string

// UserListRequestsPastParams defines parameters for UserListRequestsPast.
type UserListRequestsPastParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// UserListRequestsUpcomingParams defines parameters for UserListRequestsUpcoming.
type UserListRequestsUpcomingParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// AdminCreateAccessRuleJSONRequestBody defines body for AdminCreateAccessRule for application/json ContentType.
type AdminCreateAccessRuleJSONRequestBody CreateAccessRuleRequest

// AdminUpdateAccessRuleJSONRequestBody defines body for AdminUpdateAccessRule for application/json ContentType.
type AdminUpdateAccessRuleJSONRequestBody CreateAccessRuleRequest

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupRequest

// CreateProvidersetupJSONRequestBody defines body for CreateProvidersetup for application/json ContentType.
type CreateProvidersetupJSONRequestBody CreateProviderSetupRequest

// SubmitProvidersetupStepJSONRequestBody defines body for SubmitProvidersetupStep for application/json ContentType.
type SubmitProvidersetupStepJSONRequestBody ProviderSetupStepCompleteRequest

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserRequest

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody UpdateUserJSONBody

// UserCreateRequestJSONRequestBody defines body for UserCreateRequest for application/json ContentType.
type UserCreateRequestJSONRequestBody CreateRequestRequest

// ReviewRequestJSONRequestBody defines body for ReviewRequest for application/json ContentType.
type ReviewRequestJSONRequestBody ReviewRequest

// Getter for additional properties for AccessRuleTargetDetail_With. Returns the specified
// element and whether it was found
func (a AccessRuleTargetDetail_With) Get(fieldName string) (value AccessRuleTargetDetailArguments, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AccessRuleTargetDetail_With
func (a *AccessRuleTargetDetail_With) Set(fieldName string, value AccessRuleTargetDetailArguments) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AccessRuleTargetDetailArguments)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AccessRuleTargetDetail_With to handle AdditionalProperties
func (a *AccessRuleTargetDetail_With) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AccessRuleTargetDetailArguments)
		for fieldName, fieldBuf := range object {
			var fieldVal AccessRuleTargetDetailArguments
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AccessRuleTargetDetail_With to handle AdditionalProperties
func (a AccessRuleTargetDetail_With) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AccessRuleTargetDetailArguments_Groupings. Returns the specified
// element and whether it was found
func (a AccessRuleTargetDetailArguments_Groupings) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AccessRuleTargetDetailArguments_Groupings
func (a *AccessRuleTargetDetailArguments_Groupings) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a *AccessRuleTargetDetailArguments_Groupings) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a AccessRuleTargetDetailArguments_Groupings) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateAccessRuleTarget_With. Returns the specified
// element and whether it was found
func (a CreateAccessRuleTarget_With) Get(fieldName string) (value CreateAccessRuleTargetDetailArguments, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateAccessRuleTarget_With
func (a *CreateAccessRuleTarget_With) Set(fieldName string, value CreateAccessRuleTargetDetailArguments) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]CreateAccessRuleTargetDetailArguments)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateAccessRuleTarget_With to handle AdditionalProperties
func (a *CreateAccessRuleTarget_With) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]CreateAccessRuleTargetDetailArguments)
		for fieldName, fieldBuf := range object {
			var fieldVal CreateAccessRuleTargetDetailArguments
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateAccessRuleTarget_With to handle AdditionalProperties
func (a CreateAccessRuleTarget_With) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateAccessRuleTargetDetailArguments_Groupings. Returns the specified
// element and whether it was found
func (a CreateAccessRuleTargetDetailArguments_Groupings) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateAccessRuleTargetDetailArguments_Groupings
func (a *CreateAccessRuleTargetDetailArguments_Groupings) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateAccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a *CreateAccessRuleTargetDetailArguments_Groupings) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateAccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a CreateAccessRuleTargetDetailArguments_Groupings) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateRequestWith. Returns the specified
// element and whether it was found
func (a CreateRequestWith) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateRequestWith
func (a *CreateRequestWith) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateRequestWith to handle AdditionalProperties
func (a *CreateRequestWith) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateRequestWith to handle AdditionalProperties
func (a CreateRequestWith) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RequestAccessRuleTarget_Arguments. Returns the specified
// element and whether it was found
func (a RequestAccessRuleTarget_Arguments) Get(fieldName string) (value RequestArgument, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RequestAccessRuleTarget_Arguments
func (a *RequestAccessRuleTarget_Arguments) Set(fieldName string, value RequestArgument) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]RequestArgument)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RequestAccessRuleTarget_Arguments to handle AdditionalProperties
func (a *RequestAccessRuleTarget_Arguments) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]RequestArgument)
		for fieldName, fieldBuf := range object {
			var fieldVal RequestArgument
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RequestAccessRuleTarget_Arguments to handle AdditionalProperties
func (a RequestAccessRuleTarget_Arguments) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RequestDetail_Arguments. Returns the specified
// element and whether it was found
func (a RequestDetail_Arguments) Get(fieldName string) (value With, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RequestDetail_Arguments
func (a *RequestDetail_Arguments) Set(fieldName string, value With) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]With)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RequestDetail_Arguments to handle AdditionalProperties
func (a *RequestDetail_Arguments) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]With)
		for fieldName, fieldBuf := range object {
			var fieldVal With
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RequestDetail_Arguments to handle AdditionalProperties
func (a RequestDetail_Arguments) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List Access Rules
	// (GET /api/v1/access-rules)
	ListUserAccessRules(w http.ResponseWriter, r *http.Request)
	// Lookup an access rule based on the target
	// (GET /api/v1/access-rules/lookup)
	AccessRuleLookup(w http.ResponseWriter, r *http.Request, params AccessRuleLookupParams)
	// Get Access Rule
	// (GET /api/v1/access-rules/{ruleId})
	UserGetAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// List Access Rule approvers
	// (GET /api/v1/access-rules/{ruleId}/approvers)
	UserGetAccessRuleApprovers(w http.ResponseWriter, r *http.Request, ruleId string)
	// List Access Rules
	// (GET /api/v1/admin/access-rules)
	AdminListAccessRules(w http.ResponseWriter, r *http.Request, params AdminListAccessRulesParams)
	// Create Access Rule
	// (POST /api/v1/admin/access-rules)
	AdminCreateAccessRule(w http.ResponseWriter, r *http.Request)
	// Get Access Rule
	// (GET /api/v1/admin/access-rules/{ruleId})
	AdminGetAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Update Access Rule
	// (PUT /api/v1/admin/access-rules/{ruleId})
	AdminUpdateAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Archive Access Rule
	// (POST /api/v1/admin/access-rules/{ruleId}/archive)
	AdminArchiveAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Get Access Rule version history
	// (GET /api/v1/admin/access-rules/{ruleId}/versions)
	AdminGetAccessRuleVersions(w http.ResponseWriter, r *http.Request, ruleId string)
	// Get Access Rule Version
	// (GET /api/v1/admin/access-rules/{ruleId}/versions/{version})
	AdminGetAccessRuleVersion(w http.ResponseWriter, r *http.Request, ruleId string, version string)
	// Get deployment version details
	// (GET /api/v1/admin/deployment/version)
	AdminGetDeploymentVersion(w http.ResponseWriter, r *http.Request)
	// List groups
	// (GET /api/v1/admin/groups)
	GetGroups(w http.ResponseWriter, r *http.Request, params GetGroupsParams)
	// Create Group
	// (POST /api/v1/admin/groups)
	CreateGroup(w http.ResponseWriter, r *http.Request)
	// Get Group Details
	// (GET /api/v1/admin/groups/{groupId})
	GetGroup(w http.ResponseWriter, r *http.Request, groupId string)
	// Get identity configuration
	// (GET /api/v1/admin/identity)
	IdentityConfiguration(w http.ResponseWriter, r *http.Request)
	// Sync Identity
	// (POST /api/v1/admin/identity/sync)
	IdentitySync(w http.ResponseWriter, r *http.Request)
	// List providers
	// (GET /api/v1/admin/providers)
	ListProviders(w http.ResponseWriter, r *http.Request)
	// List providers
	// (GET /api/v1/admin/providers/{providerId})
	GetProvider(w http.ResponseWriter, r *http.Request, providerId string)
	// Get provider arg schema
	// (GET /api/v1/admin/providers/{providerId}/args)
	GetProviderArgs(w http.ResponseWriter, r *http.Request, providerId string)
	// List provider arg options
	// (GET /api/v1/admin/providers/{providerId}/args/{argId}/options)
	ListProviderArgOptions(w http.ResponseWriter, r *http.Request, providerId string, argId string, params ListProviderArgOptionsParams)
	// List the provider setups in progress
	// (GET /api/v1/admin/providersetups)
	ListProvidersetups(w http.ResponseWriter, r *http.Request)
	// Begin the setup process for a new Access Provider
	// (POST /api/v1/admin/providersetups)
	CreateProvidersetup(w http.ResponseWriter, r *http.Request)
	// Delete an in-progress provider setup
	// (DELETE /api/v1/admin/providersetups/{providersetupId})
	DeleteProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Get an in-progress provider setup
	// (GET /api/v1/admin/providersetups/{providersetupId})
	GetProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Complete a ProviderSetup
	// (POST /api/v1/admin/providersetups/{providersetupId}/complete)
	CompleteProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Get the setup instructions for an Access Provider
	// (GET /api/v1/admin/providersetups/{providersetupId}/instructions)
	GetProvidersetupInstructions(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Update the completion status for a Provider setup step
	// (PUT /api/v1/admin/providersetups/{providersetupId}/steps/{stepIndex}/complete)
	SubmitProvidersetupStep(w http.ResponseWriter, r *http.Request, providersetupId string, stepIndex int)
	// Validate the configuration for a Provider Setup
	// (POST /api/v1/admin/providersetups/{providersetupId}/validate)
	ValidateProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Your GET endpoint
	// (GET /api/v1/admin/requests)
	AdminListRequests(w http.ResponseWriter, r *http.Request, params AdminListRequestsParams)
	// Get a request
	// (GET /api/v1/admin/requests/{requestId})
	AdminGetRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// Returns a list of users
	// (GET /api/v1/admin/users)
	GetUsers(w http.ResponseWriter, r *http.Request, params GetUsersParams)
	// Create User
	// (POST /api/v1/admin/users)
	CreateUser(w http.ResponseWriter, r *http.Request)
	// Update User
	// (POST /api/v1/admin/users/{userId})
	UpdateUser(w http.ResponseWriter, r *http.Request, userId string)
	// List my requests
	// (GET /api/v1/requests)
	UserListRequests(w http.ResponseWriter, r *http.Request, params UserListRequestsParams)
	// Create a request
	// (POST /api/v1/requests)
	UserCreateRequest(w http.ResponseWriter, r *http.Request)
	// Your GET endpoint
	// (GET /api/v1/requests/past)
	UserListRequestsPast(w http.ResponseWriter, r *http.Request, params UserListRequestsPastParams)
	// Your GET endpoint
	// (GET /api/v1/requests/upcoming)
	UserListRequestsUpcoming(w http.ResponseWriter, r *http.Request, params UserListRequestsUpcomingParams)
	// Get a request
	// (GET /api/v1/requests/{requestId})
	UserGetRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// Get Access Instructions
	// (GET /api/v1/requests/{requestId}/access-instructions)
	GetAccessInstructions(w http.ResponseWriter, r *http.Request, requestId string)
	// Get Access Token
	// (GET /api/v1/requests/{requestId}/access-token)
	GetAccessToken(w http.ResponseWriter, r *http.Request, requestId string)
	// Cancel a request
	// (POST /api/v1/requests/{requestId}/cancel)
	CancelRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// List request events
	// (GET /api/v1/requests/{requestId}/events)
	ListRequestEvents(w http.ResponseWriter, r *http.Request, requestId string)
	// Review a request
	// (POST /api/v1/requests/{requestId}/review)
	ReviewRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// Revoke an active request
	// (POST /api/v1/requests/{requestid}/revoke)
	RevokeRequest(w http.ResponseWriter, r *http.Request, requestid string)
	// Get details for the current user
	// (GET /api/v1/users/me)
	GetMe(w http.ResponseWriter, r *http.Request)
	// Get a user
	// (GET /api/v1/users/{userId})
	GetUser(w http.ResponseWriter, r *http.Request, userId string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// ListUserAccessRules operation middleware
func (siw *ServerInterfaceWrapper) ListUserAccessRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserAccessRules(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AccessRuleLookup operation middleware
func (siw *ServerInterfaceWrapper) AccessRuleLookup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AccessRuleLookupParams

	// ------------- Optional query parameter "type" -------------
	if paramValue := r.URL.Query().Get("type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	// ------------- Optional query parameter "permissionSetArn.label" -------------
	if paramValue := r.URL.Query().Get("permissionSetArn.label"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "permissionSetArn.label", r.URL.Query(), &params.PermissionSetArnLabel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "permissionSetArn.label", Err: err})
		return
	}

	// ------------- Optional query parameter "accountId" -------------
	if paramValue := r.URL.Query().Get("accountId"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "accountId", r.URL.Query(), &params.AccountId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccessRuleLookup(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetAccessRule operation middleware
func (siw *ServerInterfaceWrapper) UserGetAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetAccessRuleApprovers operation middleware
func (siw *ServerInterfaceWrapper) UserGetAccessRuleApprovers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetAccessRuleApprovers(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminListAccessRules operation middleware
func (siw *ServerInterfaceWrapper) AdminListAccessRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminListAccessRulesParams

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminListAccessRules(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminCreateAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminCreateAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminCreateAccessRule(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminGetAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminUpdateAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminUpdateAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminUpdateAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminArchiveAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminArchiveAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminArchiveAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetAccessRuleVersions operation middleware
func (siw *ServerInterfaceWrapper) AdminGetAccessRuleVersions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetAccessRuleVersions(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetAccessRuleVersion operation middleware
func (siw *ServerInterfaceWrapper) AdminGetAccessRuleVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameter("simple", false, "version", chi.URLParam(r, "version"), &version)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetAccessRuleVersion(w, r, ruleId, version)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetDeploymentVersion operation middleware
func (siw *ServerInterfaceWrapper) AdminGetDeploymentVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetDeploymentVersion(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGroups operation middleware
func (siw *ServerInterfaceWrapper) GetGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGroupsParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroups(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateGroup operation middleware
func (siw *ServerInterfaceWrapper) CreateGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGroup(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGroup operation middleware
func (siw *ServerInterfaceWrapper) GetGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroup(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// IdentityConfiguration operation middleware
func (siw *ServerInterfaceWrapper) IdentityConfiguration(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.IdentityConfiguration(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// IdentitySync operation middleware
func (siw *ServerInterfaceWrapper) IdentitySync(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.IdentitySync(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListProviders operation middleware
func (siw *ServerInterfaceWrapper) ListProviders(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProviders(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProvider operation middleware
func (siw *ServerInterfaceWrapper) GetProvider(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providerId" -------------
	var providerId string

	err = runtime.BindStyledParameter("simple", false, "providerId", chi.URLParam(r, "providerId"), &providerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providerId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProvider(w, r, providerId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProviderArgs operation middleware
func (siw *ServerInterfaceWrapper) GetProviderArgs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providerId" -------------
	var providerId string

	err = runtime.BindStyledParameter("simple", false, "providerId", chi.URLParam(r, "providerId"), &providerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providerId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProviderArgs(w, r, providerId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListProviderArgOptions operation middleware
func (siw *ServerInterfaceWrapper) ListProviderArgOptions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providerId" -------------
	var providerId string

	err = runtime.BindStyledParameter("simple", false, "providerId", chi.URLParam(r, "providerId"), &providerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providerId", Err: err})
		return
	}

	// ------------- Path parameter "argId" -------------
	var argId string

	err = runtime.BindStyledParameter("simple", false, "argId", chi.URLParam(r, "argId"), &argId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "argId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProviderArgOptionsParams

	// ------------- Optional query parameter "refresh" -------------
	if paramValue := r.URL.Query().Get("refresh"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "refresh", r.URL.Query(), &params.Refresh)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "refresh", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProviderArgOptions(w, r, providerId, argId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListProvidersetups operation middleware
func (siw *ServerInterfaceWrapper) ListProvidersetups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProvidersetups(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) CreateProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProvidersetup(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) DeleteProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) GetProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CompleteProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) CompleteProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CompleteProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProvidersetupInstructions operation middleware
func (siw *ServerInterfaceWrapper) GetProvidersetupInstructions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProvidersetupInstructions(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SubmitProvidersetupStep operation middleware
func (siw *ServerInterfaceWrapper) SubmitProvidersetupStep(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	// ------------- Path parameter "stepIndex" -------------
	var stepIndex int

	err = runtime.BindStyledParameter("simple", false, "stepIndex", chi.URLParam(r, "stepIndex"), &stepIndex)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "stepIndex", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SubmitProvidersetupStep(w, r, providersetupId, stepIndex)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ValidateProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) ValidateProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ValidateProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminListRequests operation middleware
func (siw *ServerInterfaceWrapper) AdminListRequests(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminListRequestsParams

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminListRequests(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetRequest operation middleware
func (siw *ServerInterfaceWrapper) AdminGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUsers operation middleware
func (siw *ServerInterfaceWrapper) GetUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUsers(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateUser operation middleware
func (siw *ServerInterfaceWrapper) CreateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUser(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateUser operation middleware
func (siw *ServerInterfaceWrapper) UpdateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserListRequests operation middleware
func (siw *ServerInterfaceWrapper) UserListRequests(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListRequestsParams

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "reviewer" -------------
	if paramValue := r.URL.Query().Get("reviewer"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "reviewer", r.URL.Query(), &params.Reviewer)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "reviewer", Err: err})
		return
	}

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListRequests(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserCreateRequest operation middleware
func (siw *ServerInterfaceWrapper) UserCreateRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserCreateRequest(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserListRequestsPast operation middleware
func (siw *ServerInterfaceWrapper) UserListRequestsPast(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListRequestsPastParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListRequestsPast(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserListRequestsUpcoming operation middleware
func (siw *ServerInterfaceWrapper) UserListRequestsUpcoming(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListRequestsUpcomingParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListRequestsUpcoming(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetRequest operation middleware
func (siw *ServerInterfaceWrapper) UserGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetAccessInstructions operation middleware
func (siw *ServerInterfaceWrapper) GetAccessInstructions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAccessInstructions(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetAccessToken operation middleware
func (siw *ServerInterfaceWrapper) GetAccessToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAccessToken(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CancelRequest operation middleware
func (siw *ServerInterfaceWrapper) CancelRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CancelRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListRequestEvents operation middleware
func (siw *ServerInterfaceWrapper) ListRequestEvents(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRequestEvents(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ReviewRequest operation middleware
func (siw *ServerInterfaceWrapper) ReviewRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReviewRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RevokeRequest operation middleware
func (siw *ServerInterfaceWrapper) RevokeRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestid" -------------
	var requestid string

	err = runtime.BindStyledParameter("simple", false, "requestid", chi.URLParam(r, "requestid"), &requestid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestid", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RevokeRequest(w, r, requestid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetMe operation middleware
func (siw *ServerInterfaceWrapper) GetMe(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMe(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUser operation middleware
func (siw *ServerInterfaceWrapper) GetUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules", wrapper.ListUserAccessRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules/lookup", wrapper.AccessRuleLookup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules/{ruleId}", wrapper.UserGetAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules/{ruleId}/approvers", wrapper.UserGetAccessRuleApprovers)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules", wrapper.AdminListAccessRules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/access-rules", wrapper.AdminCreateAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}", wrapper.AdminGetAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}", wrapper.AdminUpdateAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}/archive", wrapper.AdminArchiveAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}/versions", wrapper.AdminGetAccessRuleVersions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}/versions/{version}", wrapper.AdminGetAccessRuleVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/deployment/version", wrapper.AdminGetDeploymentVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/groups", wrapper.GetGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/groups", wrapper.CreateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/groups/{groupId}", wrapper.GetGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/identity", wrapper.IdentityConfiguration)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/identity/sync", wrapper.IdentitySync)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers", wrapper.ListProviders)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers/{providerId}", wrapper.GetProvider)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers/{providerId}/args", wrapper.GetProviderArgs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers/{providerId}/args/{argId}/options", wrapper.ListProviderArgOptions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providersetups", wrapper.ListProvidersetups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/providersetups", wrapper.CreateProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}", wrapper.DeleteProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}", wrapper.GetProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/complete", wrapper.CompleteProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/instructions", wrapper.GetProvidersetupInstructions)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/steps/{stepIndex}/complete", wrapper.SubmitProvidersetupStep)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/validate", wrapper.ValidateProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/requests", wrapper.AdminListRequests)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/requests/{requestId}", wrapper.AdminGetRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/users", wrapper.GetUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/users", wrapper.CreateUser)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/users/{userId}", wrapper.UpdateUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests", wrapper.UserListRequests)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests", wrapper.UserCreateRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/past", wrapper.UserListRequestsPast)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/upcoming", wrapper.UserListRequestsUpcoming)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}", wrapper.UserGetRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}/access-instructions", wrapper.GetAccessInstructions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}/access-token", wrapper.GetAccessToken)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests/{requestId}/cancel", wrapper.CancelRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}/events", wrapper.ListRequestEvents)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests/{requestId}/review", wrapper.ReviewRequest)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests/{requestid}/revoke", wrapper.RevokeRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/users/me", wrapper.GetMe)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/users/{userId}", wrapper.GetUser)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9bXfbNrPgX8Fy756n7cqS7Dhp4j177qq2k+ppEvvacnL31rktREISapJgAFC2mvX+",
	"9j14I0ECpChZTtJuPsWxQWAwM5g3zAw+BSFJMpKilLPg6FNA0cccMf4TiTCSvzimCHI0CkPE2EUeows1",
	"QPwpJClHqfwRZlmMQ8gxSQd/MJKK37FwgRIofsooyRDlekaYZZQsYSx+/heKZsFR8F8HJRQD9R0bjOQ4",
	"RI9JOsPz4L4XRIiFFGdiFfExuoNJFqPgKBhFCU4BlEACTsDZDYdBL0jg3WuUzvkiODoYHj7vBRnkHNE0",
	"OAp+hXt/jvb+Y7j3otf/H0ffff/r9fWHf/0v19d7v/3+f6/z4fDg2eD6Or2+Zh/+z3/+S9AL+CoTCzFO",
	"cSphmVOSZ3I/FaiCyQIB+TcwPmGALyAHfIEMbDSPEZDIQgLQftALMEeJnMdZQv8CUgpX4v8pTFB132Kf",
	"AIrNV3d7OBz2ggSn5v/7223dt28O6RzxdbSrc81EfSW+xwk6JinjFGLNc20TTWrD7+97kkcxRVFw9Ksh",
	"Q6/kKo2nKrcUcLsAfCg2SaZ/oJAH9/diEbWDV2L6h7N8jXEfky8NkzhrNLHDf5ZL/tbf89C8hnG5QCvS",
	"zilZ4gjRS8R3gbxMTzeRC/rOmwAFkJk8aGa0EAMMcZBn/V1JgrWoqUDqQ1FNhAU/oTlOJdjzHEcoEhDn",
	"mdiDlBYzQgEEKboF6iQBg9l+UCBb43cHYrk4rOOoxkCPKE4oguzxDwXHifhpjazROJyowfe94BYLaLpI",
	"Ov3pe/FBnSsqiC1gaT1BVwzRh1MUJRBLLTsjNIE8ONK/6a0TDg7+Zpgy/nZTyfIwzsBManVLM04JiRFM",
	"xR9j+JnhqdHUILJEjAVTCXsDkSsC8pKj7JgIhc53YFyFeiZXUL5fIL4QcnGBAOMoA5gBMxoQClLC++W+",
	"LVyH0v56B+NcC4oowmJOGJ9XlnYo6ApqNRVYyrkASjmiKALTlQQqZ4iC2wUOFyAklCKWkTQSYlxCLAWj",
	"gNsCUiO1F9ztzcme/mUCs18VDB8aiFfgqLa3BmpdoCVGtzshTaI/e0xZF6EQM21otEs7sa0TM/q+Fwhj",
	"m+IITbaRljUcF1B0UYOjFEBt7P+DASoBE/ocpkbx6cX61+nEMqbVL4GSqCCEKZgiYHaRCr7CaRjnkfir",
	"+bUZrfWumWNKolX/Oh3PAObiZJAEc46inhxEKJ7jFMb1FW9xHIslc4aivkaB4FqmCD7K+UJJcvXLB/CO",
	"JQybT7U8QJgJtEmfAAsblxMqUPmKwpQLKH0nXHy4jtxiIw6V5Yft4q5O6xPEIY4ZgFOSa9co5wuUcoEK",
	"FMlNSOtGH9KaMflgTEYoi8lKHETlV15lkdbfalNNCIYggWkOY5DLDwSeDSaMjNI4BiPtijBQLqZFX04l",
	"lOC73+dq8F45pL9K4t+/F5PBkOOlWMQ2aH2kcw5d6966kGciz4TCMrhdoNToCMHv5Xk0VKnYrdIqPSlg",
	"eIeokAA7oNlSzeQ3/i0c63F98F4fTAgYSpaI9gDLwwWADFwHy2H/RX94HUjrmsxmOMTyZMcIMsR6QhVe",
	"BxFa/vdX48lvP48uf9ZDM4r29CgwzXEcsf5aM8EA3u1g1PcBcKosN7EngdtTSskupAkS83hUdt3IkcM6",
	"CnA5GFDEc5qiCMwoSbTipkscIgn/OBLnnK+O7bOwg/1UpJ102ZUL49qUGgDDvutx4HzR86/WBUsXEjnM",
	"JqslBs1KNUkh3VpsixKJyteY8TK8YkJlbAfITNGd/CbN4xhOYxQccZojj6EhJLVSTh0jWB7lwYKeWrAT",
	"l4EYMy4wojRdxMDtgki9b8wHqfusUJtW2C7GmNJDu2C+cs4KMlpDm8U3CgxvtK8bHRqdzY1Qe6pCioXo",
	"9yDsi6PqiyOp5D9jlYoZiuMoRcEu0FSGljthSK67O+QUEdUHM0/FdNsFYrLKhJ0RVIFjrViqLbIZY+B0",
	"L6NkTgV31EwlBqZIGFEqKGmcXmMzVpRKyVPa7zldig3tQvMvzUVPJ8zZy++OwzQQO+AwDd9nVXtapWyM",
	"xLWMV0y8A8TsyO18gC2w3pfctXlwDoWTLg6TbSawoB5w2wovG8iXZsMPgspQoPYiD7sJMj2YZLSMU3Vi",
	"yvtOhqt2CGfSxBeQSnfQmFcq9qGnlpGPUmk7PpulO4WpyyGumcTy1iMFKFXBAOEQJ/AGlcupEXIa4YK1",
	"XrWtvSP2+AjV72ge/3bw/PbgFE35wb89T1/+2z8Pol/g/svJ6Yt/H/7TmUJHI9U9XDA+UbHs45xSTU03",
	"/rLmYnfLO9jHuH3tNfviI5Cn+GOOSu9VOjQzjKgkmNB2Fu37QEYnNB9JZpBXH0zfeBW+/HX6foFSMwgz",
	"HYCJegDzfzAwPgEUJZKJQpIyzMSh6V+na31zHAXlbja9NLZJKmQT5orHSr53jlUvcKz+hrNRjigPSCT/",
	"jyKP86gxA9NIYofJQbZBgZcIwAx7DsvnS8X4GvInvsDJThCHEeSw+1l9Y77YQi4wDnm+gUd1qcZvLVEs",
	"5/WbXGmQK5omve6ZKgXPPET+aNK0SqE3FnPWrqokyqIRd89V9bJNwNUX1JQXheqrn1be06jQ+wYxBueo",
	"ZYRetbizFks0HUUfFHoWLxT1i8BimzbwNiD2dF48v7GI1Yzpy+JgusJOMUjtukswctALUJonAtDR8WT8",
	"7jToBaOL45/H705P/MBcGl5zUOvYAp5jppjNmF+WwHXURmaFT7sYxo0+tn8bk4LrmzFaEUCezRT68jF3",
	"VWaINN2Jby5NR3SeJ0gLxbpl3oBFDUcLMruIAz8UjmwQB/M0RuYq27Do+O351SToBW+uXk/Gl6evT4/F",
	"//QPH5oMAJzOW3MKuit3Z2PLImFhy/i0nsCGtFfZ/Vp8l1j0pSwwTrIYzxcSjcI2CdDh4smUPVncoY+r",
	"OwmPmndCbpBKhKksp37tE43u1Ku7BD6PbhZ/HA6ffVRTazX0BvEF8Vx8nsj/TREDt8UVqHHAFpCBKUJF",
	"3D0CMOdEWKUhjOMVIFRdAEFzmW/LsqvJ2ZvRZHwc9IKL03fj0/c1cVaFq9v2nj1/kcT8Ofx4l94dWtsr",
	"TFZXRJgbA52TUvqUUjowRzx4orJrmbIIi7hiX7q2wsTVeYvmBoMVRk3hXPceesOiQXeQXGDHc3waMnid",
	"vcBKCoUEXqpSZYDZzn4h1v1it+HK7iES1r+HreWsTN+rS9oGPHXG6Fp5+1eUk2vxsyv56GZfbpKgVoXR",
	"nqUbPM8JfBIe3v6YxD9yBY8M53uNK5RkhEK6ApAxPE/lPb+w+YoYFwQZxWmIMxi7jjpKI78YQWkEhPlr",
	"xIhMK5GmY+EzHgwPDvaGz/b2n0yGT46evDh6Muy/ONj/D63NpJEtbNy9TS1t22ByIRuf+FKyJXxleKAK",
	"KdFlG+3JqIxDyhttacq/GD5Yi5UfKmdNWvse4LRuPD99ezJ++0oY+sbiP724OLtQqvLsl9MT8Zt/Px9f",
	"aJ3p4CZX/OrnlQTiGMAoktdTGgbDfh7CuGnDbYSpSYXC7zUg9Wx7VdGwJ/naEhbq+HiElLrjXFdX0RDL",
	"dX6doGQqdF9eCdvglKO5MutN4KVDJUTde5fuv71AZXtiF57tjaOsdBELQ8n4egU3WFOVX3QzkOCTWUT3",
	"f5yHi+EhlDv5Ba1k3quL1Rvk9+CXZng7WsTnZrAFcbFeN9n65OkfSxTnL+72D+IDucZrQm7yrPVqASSQ",
	"hwthjlrhQqGxAZFjTOYxlry/ApCiMovP2F2+/JFeYybDZvkLDMUo5HAaI6FmziRQZWZ1dTdjdUB9WxL2",
	"dzkVmGEUR6ynEoWkklapqTp6XJlGY4ATk7gqfswomokPxEBx6lXmn968YqpOF3sFjdfZDBb+LBZxKNyN",
	"VbLFHf04fMEPZsuDPwM7wd5FapG46JC0QVZwXXXUIejHTdmP3o6VM+ZuQ+sjdV32/rLYTHGKdZi5+L/B",
	"5620WGVYves3Uq9WKg+U3f9S8M3OpCpmip9h3J6mbBcByFRr/ZU/NxmzSxRSn+dh5lS1C/bU8jzITGjA",
	"5MfguxjfIBlgOx+DGyQ9VAgyyNgtodH33pUblIA4xGLOc6iszSpQ0t6BfCFO1e0CUaSTICUUJl+ccUJl",
	"oDktIGQggSmcIwokpKP3l+Dy8g04hxQmiCMKLsU3/W7RZ79iKsljYdXDrjZvdDuAt0/h8vZPRG4Ppn+8",
	"CFw+a9AzOFpnOdr07PvimoVKcmdR/OWpMemIREeB+fbUDT+z5SFdTKPbbHaDq/hRKQMeRVbYzFp8m5JA",
	"MqumEfEFJfl84dYQ3hJ6M4vJrZjAJP+DyQKx0h5nUv/98ENK+A8/gBXiKvEcue5HUSaDI2jEQl0h9AdK",
	"qC9gGsWIDkiGUpjh/iqJW8Oox/W5PU5rtxKkGYwZ6rUY39XMWqUJtygn6nk5t7inGp8UpkRBRZUfDyZC",
	"QUu5RGEakQT8cnk1PpHe35LgCGSEo5RjKFX3LMYhZ8p8EXy7xzIU4hlGUTnv+IQZDmmqKAAzHKN++3Vh",
	"261EWX2ledB2WI7P3py/Pp0IR+Xd6PX4ZDQZn7397eVo/FrareZ30qUZvx1PxqPXvx2fvX05fnV1ocaO",
	"3/52fnH26uL08rI6yeXV8enpSZOfw5Hv8niUyjofUz9kSt0EjiKZQJPOi2hmYQCacrB+VyvHKd8702s2",
	"x1vWVS3XyyrsM+4XfG0lEeamtOZ/dxR8coj3ClNhvXYce6508AhNJei6icv9NHlC0fLFR/Tni6krLk8w",
	"nKeEcRy+Jr7ALojJXMh9ugIUxTIhTIdX7MMojr+G15V3MVqi2I9bMbn8s30Mxm9fngW94P3o4q3ideW1",
	"+zg3YfPmiRN1O7qeUApANVsTtqt42gnqxynjNA8F1J5IpWAPXd61XW7upTXBOg/CXqwJAxVwH2rKOBB6",
	"CjwLw2lzBNhWly93pYb5pljmOkdFDavN16uC3oROe/M7w2YhO13/V8nsygVUWQbcUL68dTV0caVlvok6",
	"FNwV87ehrNjhTo5g1Qiri75SqAE4h4LIlh1dNXwaVI+LRBVd0OuiBps9g5TjMI8hrRjtzEAk3Z0ZgOnK",
	"VrONSVptTkG5x7Ks7/cYM77HGNmTd16/e3VmTOZbCqaqKPVA3d2UqqqdUoHYVtDl1fGx+qkMCDdpFJ8G",
	"LxR2nXRNbGox1bZMatXH15myqJomJojFSIL4Qpg4CYyQcM7shF/LY2kJvDXcF5YD3pUmkjvKufxen/5Y",
	"jJbJC/qep70wB6qyCV/AxJdMWDZDaao6eHB2lJ7HW/7ZNYFQk9rKHtyuvcou8r187F/u0ToKGsYqJnv1",
	"5iwu99hgWsfnoggMO8F8/advOfBfQQ68Q4tvqfCfKRXePQVdjkpzduL6hL7myxo7uWKbPBIDpp7Hm0ax",
	"u5zIngXwVil9dXA3DvCriHx3W6m8y/LZRnqT7FJeWDUELTArouOc5kjaivqKSx6gotuGbkpRphjRuiS2",
	"hMqGTpHZtw9mD2sb/HY0mdiczsPDH/Ht/Nm+bTI1J7E+juG02Y3lQy2lBx8+1VPNw+YhTFXVnOcWRrOQ",
	"lUYncFY0yNFpiYgW7RWsZDuXjb5Ze387a6+W5V/yUoP0XW/vqSJpT8+DJvRXiiy2JvGMkkSy3uWXzz4S",
	"sFxux1Ti08l2jCX3oVL4Ir9tKUe8hDjOKbpoPnUN99oUhYRGKCoI7Pa+EX/RretuoRAm6gsVfxaSR3eI",
	"KlC+8Y2T5uPWbeoxDY4xJ18Lm3CyJZNwsovWdLbUkE5feRDdA6+I3k3D3+0//fPpxzBGLPr4wtbwG5f/",
	"FN3u7Lz58/OLM5UOVlLgePT2+PS1umw7OT1+PX5bTaavAuChRRVVrqWoY4aXKCRpxPzZcjKZT8ojZ4eY",
	"kefPhvsyJZNxmGTCRrmaHMtf/ElSZKcZPkgX1CF1kTAxOqELLQ8JWX2MZ8/vpvCpCXBV+iV6XRT1N2Wb",
	"kdRDUT89/ZSrLOch3cR1YGvshZN66Fd7TbUysyrNE3h34pLd5dwE3uEkT4DBvCAtUx/YeXTC3opjcqsy",
	"7PoqjVR8GBw9G/YcdqqR1QOMhaSJ44s62vlK9zZsaI3b3uq2pWp507JjNxoNW9bJcMhzih5gtpUJoo9o",
	"e/na4BrQLWvM6oxrG11uWcoV65Atd7yg2CZiEIpf/C90p1AQwynrY6JScd3cOPk1eCtwkFrQHgULzjN2",
	"NBjAJeSQsv4c80U+FS6D7sTRD0kyyAf7hwf7hwfD4b8u/+ehwO0/CVvY0BQLtqfmbbHwj4cHwyfPXqiF",
	"BT1MwYPnvuZkjYsfwymKW5z/dd83edads4SNz60A8aRbbVCH4brWVkRi4+hHM2rk3Y3f9uq466XOGrN2",
	"jaP6rs+yDW5i7gj6A+dPQzx8GuW6YzFOZ8S0kIGqGsBwP0kSkoKXUHY/zmls8V8o/zaDHInj4zSBcbub",
	"js7HgVu3x6xY4lGw3x8qppLJYMFR8KQ/7A8D2fF4IckxgBkeLPd19tgeNd3hvHHAV4gLbVKp1AOQ2VGQ",
	"vgzkIKUzhC1cNEQaVdq+VVr1HgyHTQK1GDdoaognm9/kSQLpSq9WaRAng6dzJsh/mkZAyrgP4hvfzgex",
	"zIFuRABKo4zglOtOm6rZr8z4JjPZxHRplXEo9HxnWoKEJJniVOlqmVWmM8ZAGOPvHayVO1Vp2ZJmOhtV",
	"bMab+VpU+qwyBHAf9UHJVQN4y/YYI331V7YgeRyBKQIoDYnwluR4MIXhDYshW4C963w4fILAfzuQCQvB",
	"UfAxR3RVClOdqVS2QjK2lbuo9+bUuwVEE8yYtDf4iKZAHtWegFkXt1LEUDKVjAcoiREQ0Cjg5f2KbuKm",
	"8NcAeX2VvhEI5V46QQtvmSA2yVMOpEb2LaYHSF+nef4P/iPRuQ1Vp0ixk+Hvpvk4gufsFzHqcHi4/oRW",
	"G+TWzqVcun5nMIXicBCVQqnvOBrP5icq7wnvW8VTpBtce0zt6/Q6PdViSiXfkjReAVnDwQmQaYu25KjU",
	"qUCgqopKv5zI/F9kLj9ieWXEiWxhbH8ZIYbnqjOaEpVFt1TvZdS4qEqMCGLpPzhIEJJ5JEy6EyqEy3oA",
	"gp8nk/PD4T7IU5jzBaH4TxTpTsAypqqaAbsSWcjAV6h6OfQg5tvoDrCNyfY3ZrIdsKZgG4sEfoXhiF95",
	"1IUaLU86NffYpc2hGva1HPt1zD4oKtNb2d6tYa+etD64TieLgiuE8Kx08x2fsG/no/F8FA2ed2C4uM2i",
	"vxzn142lkoW+3CEQOrybNSqhr5ujriElJqzZjuuMqZc45ohWmX26kiVLRZ6dcq/7DUq/TNp2rCN/N6F1",
	"5gZKQ7rKVDb1jcyTlHkrOJ2DTHXeNC3rGyBK0R03LUs2NkM2ssxrvb272+f6GQvBZsSXy6bC724jIQ/B",
	"630PypjzTyRaNW/Jen5x0PT24r2Do/2daUu3NbmrLM0thJQAw63kxv7D5IYmhF9pGiq2HupuxpwbK/WQ",
	"+rNZMl1o85UaMtbJehQB3guy3END9QIKq9OxY8KVn9xqzs91sr8M9wxdVP4EI2CBqTmshm7LzrEYqjro",
	"LeHgJclTOeKpb6lxyhFNYQwuERVmmGS5GqspKuxEAgwgDRd4qSpUH4s7vfrkDaQ3rO6SChtUART1r9NR",
	"ugIZSuUbVqZDuLZLMav1OVD5UyFMQxTHPrtS4mWkJv//V2QVXLe9oNM4rLBfV27T0qXZrCzbhZv80QVm",
	"nNCVfhDUsgE3VE7vzNKPYGTtSCS06ZM6Pj6jftmQtoNP+qf7DlTWdb1hsT3/LW1H4n4zQCyGKXHymRil",
	"551oaZFme5YrC7sHVup5K3NxqxrYqi9o5Cbn9batJEXzG3Autdzn20wEtYs+L+/jm0x4mX0AiubL1W2/",
	"QvrVnnX++Nfu/NbeHvJ4vAUGNvR1hT2sQmm6z8AxmaeYExUBywiJATaPZqIUTr12h/WY+vbWcuUt9sd0",
	"gfWDSl+J37sDa0WTsmg/1u1UDT7N1eN263WYU7qkWKbfeOAeU0k1kk9oJkf+yNHgpFHkdNETGk8PFO/m",
	"AcDWgMQmbwc62Pe+v7iVhG9/yfHLcbpEURMy1vK9+XLAVmkovUGvZLzI0yrWxXBQoBpIFZbANGokwKWY",
	"34/33RlTD0amgBIYkLvgr2gs1B4xL4f5MjXOrb8+/oW03cy960X0FyGGg7nu1Bh8KjsYt4c7i/yN6Uql",
	"EzjS2+pp92gC3CqR+4vRoIuyqHSTfoi+8NN3AOm8+fzNhUEsr2rp/FKuBdSAqaxSUH+w4ktWUWIjK4zo",
	"nO2IHTbtITYyu/jqWKVymiCdA73Xr5dnBp8gnYv/WNWfa31LPbYxMHVuoUAWVckedMVnCVypiGW4kO3p",
	"CKBoRhFT/ezkr3uyS6PqcKb/+DuQzhUo8NZvVSQjOj8rCjtbvTycmm4l5fryXS0bKoO3f5jOlY1XsPor",
	"n8dXNpRpd/m6HoiSKcvdfgXmWEVgymNQlth+xnPgD8pIdt/VeSpepO1g9uhKMUgRYBzH8Zoej+3crVfe",
	"NnDQ8Eavh4xuP0PZetA8d7tBZOEnNMdaflRaVpr9K2GSlsk+dm8iX2ChgovtAwy1V0JbAw3tmPW/N7pl",
	"2KBCCok7tydjM86C+zVMW2oC+X9tIkbI3zfrAiVkqS5U7beOa731hMxUM6jwWwQ5rBRDYi6TvWxVosZH",
	"lW6FVWKfyBEusTfl+wbqVPCs1mrfpiwIasuHU8iwW63VQvvNjG3ZV4+7UZ3l0LLLh4lqzVQ7lbMuyw7s",
	"Tm+PDFyTWBvPwEWeyscnKmERKzKqW7TLm9pbirWdUbeVdLFwtXKPcULhXJkjsk2vsFIwl+mIjctGmNnr",
	"FsUDEUEMpER2kvAIVY3LhzNgfaY2RjRj668kb+TqNrFHvX3i5zq2tQ6Uj+4yu20vu8ZBN9r4X0MmyHa1",
	"g0/in3EaobtWKeGrzEYCGRG6EydSFS7qgylnUadSVm/rwlbPlovFu2zWKoJ9FLGVNzwMo4sy6+2qHe6+",
	"zKcJrjL4JUdbWVxOl0xz/NdkQj1c4V2tIaQlf6x2ozuRQsa7/IJKyvSCZM19Qau5+5nTkjrPpO32Xigx",
	"lcKuM90PhkNw9gsw5JBtMXSiPUXS3bHak8oseKbCAepnEMIUTBGYkTyVDftxyjIUchOZsj6Oin6cZfvz",
	"ehfq3/WzAX5YD4fDElBce6cqhGlKuICl6F4KvhNo0WXIPecdC+a2fBf7xamRON+7p8mQ4vPYee8qkQ23",
	"KUDJ9J21rklHWxMpsio9oCSD/qoxT/6iHNEqpEmCuQ5TimFFiYhaheUxZ1skx3vaMlT7bJjuG3+HpHmD",
	"6gam+d8kp+DV6aSwHDdhi8GnoslKhyyoMgeybJXhz1EpWzE9dsnY+iSnwy8VW670vduyTsZqgfMQO6x4",
	"5NRL4JeIh4tasZc3EedK/+EvnYcjNtFAtQtv3duWGTmm3d/DEnJ0u40tw2Vqr4+fjiOh/Ptl45heJ+vE",
	"qeSSwSfxjxak64+2Grwbi1Hby9DwXBjnMhldJYWpmku2wJlbxCg/9PNYZ8Z46BvMtf4bVsuZ2pO/949Z",
	"etHEwpVyi78G92p2WM+9a61DeatgRvWv04ls1qn7clo3fKp9FAMrkgsTbyYVSlEKoe5SxN+E+6C+9xfU",
	"/s1MS7YgtyUa+ALy8j3Xao/TGaE9QKF+7wKmTV8tIFOty/gCJQzFS8QabzbV1O1Xm383a1gybLKyPRi/",
	"6dVQ61Pp3+7p6StdVWkGgSRnXNcFrGqlAKoBcgJvKu2P++CqKJq3as3dvvF24bt8f9DUyWtOsFeiaIYo",
	"SkPE+uBMsM8tZsjUtYPD4WHpQpvio/aa9spD29tbHnqCz2F8FGu02B8+7b7GPvfIyUEGFdt4hWWEWRbD",
	"FZCnvqjw6gF0l2H5lqRKU1iSG9l2tBCqayXhOVQd0//KVvfGXqwX/3kWEtMFs5UGTjmevJNRjQuimnCV",
	"D8yptqrxSr+vCAiV6UBRHqsjOpWXukIOqLfLcQpmOc8pWq/IrgzQ30i4acSh6M5RjwMaFWpelS06TKtX",
	"Y43yk+JaCmywPgBiOouIAVh3iCqsinr6fMFCAgLT6J1bDXolhN+lhKMj0xffawKYnm2VZb9v7DfyLbLy",
	"tURWfCxkSg4732WaBqzOfV5hNNg5GDYTkhQIPVPaKPIYkFiKLooYyWmIvLefynx4hGvPjVNDXUC6XoVq",
	"E6j+euDXyAtSmHdhAiX1Pw/1jZp45DJUtczXKEI0Axk8fF2co4zHjr0OtgOhMZQkXRThpysg3Kh/ocRW",
	"YAGXpi9HJLz8GOmgpg57al9ZNav3RDjlCjvSaE6waLeBnC/CqMeaBJs7KjY3yacP2GcxtrxpsHab/u2z",
	"YCuzfC150+ZIILO3r0uO0OLtnc8uR1RvfI/0KB5FUp2AQRlSLJ7/kZGVKXLa/DmRFJ0EoD4XrIkpILdl",
	"8Kxn5zfoFoRrWgc6HKw28oB4SHWCrXJmzBQNl1YK09sLCaxYhdygjVgF74hVVEde20PXGkjBVGa5oCUm",
	"ORM+unbk++B0NkPKYcdJgiIMOYpXwEdEcoPaNc1fXltcaHSlJobRlSHU9ZV65qBzDXlZ2VzGTmIyn6s+",
	"1v4u368Qf4O20gCjnC+qF7edetl4WlmUnX/r3npHPNnXfGsUqvHtG7FR3Lx9oUutx2gGBFuQ2Xuki1EJ",
	"hWxEpqYtu+YfDQYxCWG8IIwfPR8+HwZCEGnQip77BYj3veJ36r7s/sP9/wsAAP//0T+W44DDAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	pathPrefix := path.Dir(pathToFile)

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(pathPrefix, "./accesshandler/openapi.yml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
