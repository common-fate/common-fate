// Package types provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package types

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	externalRef0 "github.com/common-fate/granted-approvals/accesshandler/pkg/types"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// Defines values for AccessRuleStatus.
const (
	AccessRuleStatusACTIVE   AccessRuleStatus = "ACTIVE"
	AccessRuleStatusARCHIVED AccessRuleStatus = "ARCHIVED"
)

// Defines values for AccessRuleTargetDetailArgumentsFormElement.
const (
	INPUT       AccessRuleTargetDetailArgumentsFormElement = "INPUT"
	MULTISELECT AccessRuleTargetDetailArgumentsFormElement = "MULTISELECT"
)

// Defines values for ApprovalMethod.
const (
	AUTOMATIC ApprovalMethod = "AUTOMATIC"
	REVIEWED  ApprovalMethod = "REVIEWED"
)

// Defines values for GrantStatus.
const (
	GrantStatusACTIVE  GrantStatus = "ACTIVE"
	GrantStatusERROR   GrantStatus = "ERROR"
	GrantStatusEXPIRED GrantStatus = "EXPIRED"
	GrantStatusPENDING GrantStatus = "PENDING"
	GrantStatusREVOKED GrantStatus = "REVOKED"
)

// Defines values for IdpStatus.
const (
	IdpStatusACTIVE   IdpStatus = "ACTIVE"
	IdpStatusARCHIVED IdpStatus = "ARCHIVED"
)

// Defines values for ProviderSetupStatus.
const (
	COMPLETE                       ProviderSetupStatus = "COMPLETE"
	INITIALCONFIGURATIONINPROGRESS ProviderSetupStatus = "INITIAL_CONFIGURATION_IN_PROGRESS"
	VALIDATING                     ProviderSetupStatus = "VALIDATING"
	VALIDATIONFAILED               ProviderSetupStatus = "VALIDATION_FAILED"
	VALIDATIONSUCEEDED             ProviderSetupStatus = "VALIDATION_SUCEEDED"
)

// Defines values for ProviderSetupDiagnosticLogLevel.
const (
	ProviderSetupDiagnosticLogLevelERROR   ProviderSetupDiagnosticLogLevel = "ERROR"
	ProviderSetupDiagnosticLogLevelINFO    ProviderSetupDiagnosticLogLevel = "INFO"
	ProviderSetupDiagnosticLogLevelWARNING ProviderSetupDiagnosticLogLevel = "WARNING"
)

// Defines values for ProviderSetupValidationStatus.
const (
	ProviderSetupValidationStatusERROR      ProviderSetupValidationStatus = "ERROR"
	ProviderSetupValidationStatusINPROGRESS ProviderSetupValidationStatus = "IN_PROGRESS"
	ProviderSetupValidationStatusPENDING    ProviderSetupValidationStatus = "PENDING"
	ProviderSetupValidationStatusSUCCESS    ProviderSetupValidationStatus = "SUCCESS"
)

// Defines values for RequestEventFromGrantStatus.
const (
	RequestEventFromGrantStatusACTIVE  RequestEventFromGrantStatus = "ACTIVE"
	RequestEventFromGrantStatusERROR   RequestEventFromGrantStatus = "ERROR"
	RequestEventFromGrantStatusEXPIRED RequestEventFromGrantStatus = "EXPIRED"
	RequestEventFromGrantStatusPENDING RequestEventFromGrantStatus = "PENDING"
	RequestEventFromGrantStatusREVOKED RequestEventFromGrantStatus = "REVOKED"
)

// Defines values for RequestEventToGrantStatus.
const (
	RequestEventToGrantStatusACTIVE  RequestEventToGrantStatus = "ACTIVE"
	RequestEventToGrantStatusERROR   RequestEventToGrantStatus = "ERROR"
	RequestEventToGrantStatusEXPIRED RequestEventToGrantStatus = "EXPIRED"
	RequestEventToGrantStatusPENDING RequestEventToGrantStatus = "PENDING"
	RequestEventToGrantStatusREVOKED RequestEventToGrantStatus = "REVOKED"
)

// Defines values for RequestStatus.
const (
	RequestStatusAPPROVED  RequestStatus = "APPROVED"
	RequestStatusCANCELLED RequestStatus = "CANCELLED"
	RequestStatusDECLINED  RequestStatus = "DECLINED"
	RequestStatusPENDING   RequestStatus = "PENDING"
)

// Defines values for ReviewDecision.
const (
	APPROVED ReviewDecision = "APPROVED"
	DECLINED ReviewDecision = "DECLINED"
)

// Access Rule contains information for an end user to make a request for access.
type AccessRule struct {
	Description string `json:"description"`
	ID          string `json:"id"`
	IsCurrent   bool   `json:"isCurrent"`
	Name        string `json:"name"`

	// A target for an access rule
	Target AccessRuleTarget `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`

	// A unique version identifier for the Access Rule. Updating a rule creates a new version.
	// When a rule is updated, it's ID remains consistent.
	Version string `json:"version"`
}

// AccessRuleDetail contains detailed information about a rule and is used in administrative apis.
type AccessRuleDetail struct {
	// Approver config for access rules
	Approval    ApproverConfig `json:"approval"`
	Description string         `json:"description"`

	// The group IDs that the access rule applies to.
	Groups    []string           `json:"groups"`
	ID        string             `json:"id"`
	IsCurrent bool               `json:"isCurrent"`
	Metadata  AccessRuleMetadata `json:"metadata"`
	Name      string             `json:"name"`

	// The status of an Access Rule.
	Status AccessRuleStatus `json:"status"`

	// A detailed target for an access rule
	Target AccessRuleTargetDetail `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`

	// A unique version identifier for the Access Rule. Updating a rule creates a new version.
	// When a rule is updated, it's ID remains consistent.
	Version string `json:"version"`
}

// AccessRuleMetadata defines model for AccessRuleMetadata.
type AccessRuleMetadata struct {
	CreatedAt     time.Time `json:"createdAt"`
	CreatedBy     string    `json:"createdBy"`
	UpdateMessage *string   `json:"updateMessage,omitempty"`
	UpdatedAt     time.Time `json:"updatedAt"`
	UpdatedBy     string    `json:"updatedBy"`
}

// The status of an Access Rule.
type AccessRuleStatus string

// A target for an access rule
type AccessRuleTarget struct {
	// Provider
	Provider Provider `json:"provider"`
}

// A detailed target for an access rule
type AccessRuleTargetDetail struct {
	// Provider
	Provider Provider                    `json:"provider"`
	With     AccessRuleTargetDetail_With `json:"with"`
}

// AccessRuleTargetDetail_With defines model for AccessRuleTargetDetail.With.
type AccessRuleTargetDetail_With struct {
	AdditionalProperties map[string]AccessRuleTargetDetailArguments `json:"-"`
}

// AccessRuleTargetDetailArguments defines model for AccessRuleTargetDetailArguments.
type AccessRuleTargetDetailArguments struct {
	FormElement AccessRuleTargetDetailArgumentsFormElement `json:"formElement"`
	Groupings   AccessRuleTargetDetailArguments_Groupings  `json:"groupings"`
	Values      []string                                   `json:"values"`
}

// AccessRuleTargetDetailArgumentsFormElement defines model for AccessRuleTargetDetailArguments.FormElement.
type AccessRuleTargetDetailArgumentsFormElement string

// AccessRuleTargetDetailArguments_Groupings defines model for AccessRuleTargetDetailArguments.Groupings.
type AccessRuleTargetDetailArguments_Groupings struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// AccessToken defines model for AccessToken.
type AccessToken = string

// Describes whether a request has been approved automatically or from a review
type ApprovalMethod string

// Approver config for access rules
type ApproverConfig struct {
	Groups []string `json:"groups"`

	// The user IDs of the approvers for the request.
	Users []string `json:"users"`
}

// a request body for creating a Access Rule Target
type CreateAccessRuleTarget struct {
	ProviderId string                      `json:"providerId"`
	With       CreateAccessRuleTarget_With `json:"with"`
}

// CreateAccessRuleTarget_With defines model for CreateAccessRuleTarget.With.
type CreateAccessRuleTarget_With struct {
	AdditionalProperties map[string]CreateAccessRuleTargetDetailArguments `json:"-"`
}

// CreateAccessRuleTargetDetailArguments defines model for CreateAccessRuleTargetDetailArguments.
type CreateAccessRuleTargetDetailArguments struct {
	Groupings CreateAccessRuleTargetDetailArguments_Groupings `json:"groupings"`
	Values    []string                                        `json:"values"`
}

// CreateAccessRuleTargetDetailArguments_Groupings defines model for CreateAccessRuleTargetDetailArguments.Groupings.
type CreateAccessRuleTargetDetailArguments_Groupings struct {
	AdditionalProperties map[string][]string `json:"-"`
}

// CreateRequestWith defines model for CreateRequestWith.
type CreateRequestWith struct {
	AdditionalProperties map[string]string `json:"-"`
}

// A temporary assignment of a user to a principal.
type Grant struct {
	// The end time of the grant.
	End time.Time `json:"end"`

	// The ID of the provider to grant access to.
	Provider string `json:"provider"`

	// The start time of the grant.
	Start time.Time `json:"start"`

	// The current state of the grant.
	Status GrantStatus `json:"status"`

	// The email address of the user to grant access to.
	Subject openapi_types.Email `json:"subject"`
}

// The current state of the grant.
type GrantStatus string

// Group defines model for Group.
type Group struct {
	Description string `json:"description"`
	Id          string `json:"id"`
	MemberCount int    `json:"memberCount"`
	Name        string `json:"name"`
}

// IdpStatus defines model for IdpStatus.
type IdpStatus string

// KeyValue defines model for KeyValue.
type KeyValue struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// A matched access rule with option values if they are required for the access rule request
type LookupAccessRule struct {
	// Access Rule contains information for an end user to make a request for access.
	AccessRule AccessRule `json:"accessRule"`

	// If the matched access rule has selectable fields, this array will contain the matched values to be used to prefill the form when requesting
	SelectableWithOptionValues *[]KeyValue `json:"selectableWithOptionValues,omitempty"`
}

// Provider
type Provider struct {
	Id   string `json:"id"`
	Type string `json:"type"`
}

// ProviderConfigField defines model for ProviderConfigField.
type ProviderConfigField struct {
	Description string `json:"description"`
	Id          string `json:"id"`

	// Whether the config value is optional.
	IsOptional bool `json:"isOptional"`

	// Whether or not the config field is a secret (like an API key or a password)
	IsSecret bool   `json:"isSecret"`
	Name     string `json:"name"`

	// the path to where the secret will be stored, in a secrets manager like AWS SSM Parameter Store.
	SecretPath *string `json:"secretPath,omitempty"`
}

// ProviderConfigValue defines model for ProviderConfigValue.
type ProviderConfigValue struct {
	// The ID of the config field.
	Id string `json:"id"`

	// The value entered by the user.
	Value string `json:"value"`
}

// A provider in the process of being set up through the guided setup workflow in Granted. These providers are **not** yet active.
type ProviderSetup struct {
	ConfigValidation []externalRef0.ProviderConfigValidation `json:"configValidation"`

	// The current configuration values.
	ConfigValues map[string]string `json:"configValues"`

	// A unique ID for the provider setup. This is a random KSUID to avoid potential conflicts with user-specified provider IDs in the `granted-deployment.yml` file.
	Id string `json:"id"`

	// The status of the setup process.
	Status ProviderSetupStatus `json:"status"`

	// An overview of the steps indicating whether they are complete.
	Steps []ProviderSetupStepOverview `json:"steps"`

	// The type of the Access Provider being set up.
	Type string `json:"type"`

	// The version of the provider.
	Version string `json:"version"`
}

// The status of the setup process.
type ProviderSetupStatus string

// A log entry related to a provider setup validation.
type ProviderSetupDiagnosticLog struct {
	// The log level.
	Level ProviderSetupDiagnosticLogLevel `json:"level"`

	// The log message.
	Msg string `json:"msg"`
}

// The log level.
type ProviderSetupDiagnosticLogLevel string

// ProviderSetupInstructions defines model for ProviderSetupInstructions.
type ProviderSetupInstructions struct {
	StepDetails []ProviderSetupStepDetails `json:"stepDetails"`
}

// ProviderSetupStepDetails defines model for ProviderSetupStepDetails.
type ProviderSetupStepDetails struct {
	ConfigFields []ProviderConfigField `json:"configFields"`
	Instructions string                `json:"instructions"`
	Title        string                `json:"title"`
}

// Indicates whether a setup step is complete or not.
type ProviderSetupStepOverview struct {
	// Whether the step has been completed.
	Complete bool `json:"complete"`
}

// A validation against the configuration values of the Access Provider.
type ProviderSetupValidation struct {
	// The particular config fields validated, if any.
	FieldsValidated []interface{} `json:"fieldsValidated"`

	// The ID of the validation, such as `list-sso-users`.
	Id   string                        `json:"id"`
	Logs *[]ProviderSetupDiagnosticLog `json:"logs,omitempty"`

	// The status of the validation.
	Status ProviderSetupValidationStatus `json:"status"`
}

// The status of the validation.
type ProviderSetupValidationStatus string

// A request to access something made by an end user in Granted.
type Request struct {
	AccessRuleId      string `json:"accessRuleId"`
	AccessRuleVersion string `json:"accessRuleVersion"`

	// Describes whether a request has been approved automatically or from a review
	ApprovalMethod *ApprovalMethod `json:"approvalMethod,omitempty"`

	// A temporary assignment of a user to a principal.
	Grant       *Grant    `json:"grant,omitempty"`
	ID          string    `json:"id"`
	Reason      *string   `json:"reason,omitempty"`
	RequestedAt time.Time `json:"requestedAt"`
	Requestor   string    `json:"requestor"`

	// The status of an Access Request.
	Status    RequestStatus `json:"status"`
	Timing    RequestTiming `json:"timing"`
	UpdatedAt time.Time     `json:"updatedAt"`
}

// Access Rule contains information for an end user to make a request for access.
type RequestAccessRule struct {
	Description string `json:"description"`
	ID          string `json:"id"`
	IsCurrent   bool   `json:"isCurrent"`
	Name        string `json:"name"`

	// A detailed target for an access rule request
	Target RequestAccessRuleTarget `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`

	// A unique version identifier for the Access Rule. Updating a rule creates a new version.
	// When a rule is updated, it's ID remains consistent.
	Version string `json:"version"`
}

// A detailed target for an access rule request
type RequestAccessRuleTarget struct {
	Arguments RequestAccessRuleTarget_Arguments `json:"arguments"`

	// Provider
	Provider Provider `json:"provider"`
}

// RequestAccessRuleTarget_Arguments defines model for RequestAccessRuleTarget.Arguments.
type RequestAccessRuleTarget_Arguments struct {
	AdditionalProperties map[string]RequestArgument `json:"-"`
}

// RequestArgument defines model for RequestArgument.
type RequestArgument struct {
	Description *string      `json:"description,omitempty"`
	Options     []WithOption `json:"options"`

	// This will be true if a selection is require when creating a request
	RequiresSelection bool   `json:"requiresSelection"`
	Title             string `json:"title"`
}

// A request to access something made by an end user in Granted.
type RequestDetail struct {
	// Access Rule contains information for an end user to make a request for access.
	AccessRule AccessRule `json:"accessRule"`

	// Describes whether a request has been approved automatically or from a review
	ApprovalMethod *ApprovalMethod         `json:"approvalMethod,omitempty"`
	Arguments      RequestDetail_Arguments `json:"arguments"`

	// true if the requesting user is a reviewer of this request.
	CanReview bool `json:"canReview"`

	// A temporary assignment of a user to a principal.
	Grant       *Grant    `json:"grant,omitempty"`
	ID          string    `json:"id"`
	Reason      *string   `json:"reason,omitempty"`
	RequestedAt time.Time `json:"requestedAt"`
	Requestor   string    `json:"requestor"`

	// The status of an Access Request.
	Status    RequestStatus `json:"status"`
	Timing    RequestTiming `json:"timing"`
	UpdatedAt time.Time     `json:"updatedAt"`
}

// RequestDetail_Arguments defines model for RequestDetail.Arguments.
type RequestDetail_Arguments struct {
	AdditionalProperties map[string]With `json:"-"`
}

// RequestEvent defines model for RequestEvent.
type RequestEvent struct {
	Actor     *string   `json:"actor,omitempty"`
	CreatedAt time.Time `json:"createdAt"`

	// The current state of the grant.
	FromGrantStatus *RequestEventFromGrantStatus `json:"fromGrantStatus,omitempty"`

	// The status of an Access Request.
	FromStatus         *RequestStatus `json:"fromStatus,omitempty"`
	FromTiming         *RequestTiming `json:"fromTiming,omitempty"`
	GrantCreated       *bool          `json:"grantCreated,omitempty"`
	GrantFailureReason *string        `json:"grantFailureReason,omitempty"`
	Id                 string         `json:"id"`

	// An event which was recorded relating to the grant.
	RecordedEvent  *map[string]string `json:"recordedEvent,omitempty"`
	RequestCreated *bool              `json:"requestCreated,omitempty"`
	RequestId      string             `json:"requestId"`

	// The current state of the grant.
	ToGrantStatus *RequestEventToGrantStatus `json:"toGrantStatus,omitempty"`

	// The status of an Access Request.
	ToStatus *RequestStatus `json:"toStatus,omitempty"`
	ToTiming *RequestTiming `json:"toTiming,omitempty"`
}

// The current state of the grant.
type RequestEventFromGrantStatus string

// The current state of the grant.
type RequestEventToGrantStatus string

// The status of an Access Request.
type RequestStatus string

// RequestTiming defines model for RequestTiming.
type RequestTiming struct {
	DurationSeconds int `json:"durationSeconds"`

	// iso8601 timestamp in UTC timezone
	StartTime *time.Time `json:"startTime,omitempty"`
}

// A decision made on an Access Request.
type ReviewDecision string

// Time configuration for an Access Rule.
type TimeConstraints struct {
	// The maximum duration in seconds the access is allowed for.
	MaxDurationSeconds int `json:"maxDurationSeconds"`
}

// User defines model for User.
type User struct {
	Email     string    `json:"email"`
	FirstName string    `json:"firstName"`
	Groups    []string  `json:"groups"`
	Id        string    `json:"id"`
	LastName  string    `json:"lastName"`
	Picture   string    `json:"picture"`
	Status    IdpStatus `json:"status"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// With defines model for With.
type With struct {
	FieldDescription  *string `json:"fieldDescription,omitempty"`
	Label             string  `json:"label"`
	OptionDescription *string `json:"optionDescription,omitempty"`
	Title             string  `json:"title"`
	Value             string  `json:"value"`
}

// WithOption defines model for WithOption.
type WithOption struct {
	Description *string `json:"description,omitempty"`
	Label       string  `json:"label"`
	Valid       bool    `json:"valid"`
	Value       string  `json:"value"`
}

// AuthUserResponse defines model for AuthUserResponse.
type AuthUserResponse struct {
	// Whether the user is an administrator of Granted.
	IsAdmin bool `json:"isAdmin"`
	User    User `json:"user"`
}

// CompleteProviderSetupResponse defines model for CompleteProviderSetupResponse.
type CompleteProviderSetupResponse struct {
	// Whether a manual update is required to the Granted Approvals deployment configuration (`granted-deployment.yml`) to activate the provider.
	DeploymentConfigUpdateRequired bool `json:"deploymentConfigUpdateRequired"`
}

// DeploymentVersionResponse defines model for DeploymentVersionResponse.
type DeploymentVersionResponse struct {
	// The deployment version. Will be a semver, such as "v0.9.0" for official releases, or "dev+GIT_HASH" for pre-release builds.
	Version string `json:"version"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error string `json:"error"`
}

// IdentityConfigurationResponse defines model for IdentityConfigurationResponse.
type IdentityConfigurationResponse struct {
	AdministratorGroupId string `json:"administratorGroupId"`
	IdentityProvider     string `json:"identityProvider"`
}

// ListAccessRuleApproversResponse defines model for ListAccessRuleApproversResponse.
type ListAccessRuleApproversResponse struct {
	Next  *string  `json:"next"`
	Users []string `json:"users"`
}

// ListAccessRulesDetailResponse defines model for ListAccessRulesDetailResponse.
type ListAccessRulesDetailResponse struct {
	AccessRules []AccessRuleDetail `json:"accessRules"`
	Next        *string            `json:"next"`
}

// ListAccessRulesResponse defines model for ListAccessRulesResponse.
type ListAccessRulesResponse struct {
	AccessRules []AccessRule `json:"accessRules"`
	Next        *string      `json:"next"`
}

// ListGroupsResponse defines model for ListGroupsResponse.
type ListGroupsResponse struct {
	Groups []Group `json:"groups"`
	Next   *string `json:"next"`
}

// ListProviderSetupsResponse defines model for ListProviderSetupsResponse.
type ListProviderSetupsResponse struct {
	ProviderSetups []ProviderSetup `json:"providerSetups"`
}

// ListRequestEventsResponse defines model for ListRequestEventsResponse.
type ListRequestEventsResponse struct {
	Events []RequestEvent `json:"events"`
	Next   *string        `json:"next"`
}

// ListRequestsResponse defines model for ListRequestsResponse.
type ListRequestsResponse struct {
	Next     *string   `json:"next"`
	Requests []Request `json:"requests"`
}

// ListUserResponse defines model for ListUserResponse.
type ListUserResponse struct {
	Next  *string `json:"next"`
	Users []User  `json:"users"`
}

// OperationResponse defines model for OperationResponse.
type OperationResponse struct {
	Data map[string]interface{} `json:"data"`
}

// A provider in the process of being set up through the guided setup workflow in Granted. These providers are **not** yet active.
type ProviderSetupResponse = ProviderSetup

// ReviewResponse defines model for ReviewResponse.
type ReviewResponse struct {
	// A request to access something made by an end user in Granted.
	Request *Request `json:"request,omitempty"`
}

// CreateAccessRuleRequest defines model for CreateAccessRuleRequest.
type CreateAccessRuleRequest struct {
	// Approver config for access rules
	Approval    ApproverConfig `json:"approval"`
	Description string         `json:"description"`

	// The group IDs that the access rule applies to.
	Groups []string `json:"groups"`
	Name   string   `json:"name"`

	// a request body for creating a Access Rule Target
	Target CreateAccessRuleTarget `json:"target"`

	// Time configuration for an Access Rule.
	TimeConstraints TimeConstraints `json:"timeConstraints"`
}

// CreateGroupRequest defines model for CreateGroupRequest.
type CreateGroupRequest struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
}

// CreateProviderSetupRequest defines model for CreateProviderSetupRequest.
type CreateProviderSetupRequest struct {
	// The type of the provider to set up.
	ProviderType string `json:"providerType"`
}

// CreateRequestRequest defines model for CreateRequestRequest.
type CreateRequestRequest struct {
	AccessRuleId string             `json:"accessRuleId"`
	Reason       *string            `json:"reason,omitempty"`
	Timing       RequestTiming      `json:"timing"`
	With         *CreateRequestWith `json:"with,omitempty"`
}

// CreateUserRequest defines model for CreateUserRequest.
type CreateUserRequest struct {
	Email     openapi_types.Email `json:"email"`
	FirstName string              `json:"firstName"`
	IsAdmin   bool                `json:"isAdmin"`
	LastName  string              `json:"lastName"`
}

// OperationRequest defines model for OperationRequest.
type OperationRequest struct {
	// Arguments specific to the operation.
	Args *map[string]any `json:"args,omitempty"`

	// The ID of the operation to execute
	Operation string `json:"operation"`
}

// ProviderSetupStepCompleteRequest defines model for ProviderSetupStepCompleteRequest.
type ProviderSetupStepCompleteRequest struct {
	// Whether the step is complete or not.
	Complete bool `json:"complete"`

	// The config values entered by the user which correspond to the setup step.
	ConfigValues map[string]string `json:"configValues"`
}

// ReviewRequest defines model for ReviewRequest.
type ReviewRequest struct {
	Comment *string `json:"comment,omitempty"`

	// A decision made on an Access Request.
	Decision       ReviewDecision `json:"decision"`
	OverrideTiming *RequestTiming `json:"overrideTiming,omitempty"`
}

// AccessRuleLookupParams defines parameters for AccessRuleLookup.
type AccessRuleLookupParams struct {
	// the provider type i.e. commonfate/aws-sso. type should be encoded i.e.  backslash -> %2
	Type *AccessRuleLookupParamsType `form:"type,omitempty" json:"type,omitempty"`

	// the permissionSetArn label, typically resembles a role name i.e. AdminstratorAccess
	PermissionSetArnLabel *string `form:"permissionSetArn.label,omitempty" json:"permissionSetArn.label,omitempty"`

	// the aws account id
	AccountId *string `form:"accountId,omitempty" json:"accountId,omitempty"`
}

// AccessRuleLookupParamsType defines parameters for AccessRuleLookup.
type AccessRuleLookupParamsType string

// AdminListAccessRulesParams defines parameters for AdminListAccessRules.
type AdminListAccessRulesParams struct {
	// Filter Access Rules by a particular status.
	Status *AdminListAccessRulesParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// AdminListAccessRulesParamsStatus defines parameters for AdminListAccessRules.
type AdminListAccessRulesParamsStatus string

// GetGroupsParams defines parameters for GetGroups.
type GetGroupsParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// ListProviderArgOptionsParams defines parameters for ListProviderArgOptions.
type ListProviderArgOptionsParams struct {
	// invalidate the cache and refresh the provider's options.
	Refresh *bool `form:"refresh,omitempty" json:"refresh,omitempty"`
}

// AdminListRequestsParams defines parameters for AdminListRequests.
type AdminListRequestsParams struct {
	// omit this param to view all results
	Status *AdminListRequestsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// AdminListRequestsParamsStatus defines parameters for AdminListRequests.
type AdminListRequestsParamsStatus string

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody struct {
	Groups []string `json:"groups"`
}

// UserListRequestsParams defines parameters for UserListRequests.
type UserListRequestsParams struct {
	// omit this param to view all results
	Status *UserListRequestsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// show requests that the user is a reviewer for, rather than requests that the user has made themselves
	Reviewer *bool `form:"reviewer,omitempty" json:"reviewer,omitempty"`

	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// UserListRequestsParamsStatus defines parameters for UserListRequests.
type UserListRequestsParamsStatus string

// UserListRequestsPastParams defines parameters for UserListRequestsPast.
type UserListRequestsPastParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// UserListRequestsUpcomingParams defines parameters for UserListRequestsUpcoming.
type UserListRequestsUpcomingParams struct {
	// encrypted token containing pagination info
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// AdminCreateAccessRuleJSONRequestBody defines body for AdminCreateAccessRule for application/json ContentType.
type AdminCreateAccessRuleJSONRequestBody CreateAccessRuleRequest

// AdminUpdateAccessRuleJSONRequestBody defines body for AdminUpdateAccessRule for application/json ContentType.
type AdminUpdateAccessRuleJSONRequestBody CreateAccessRuleRequest

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupRequest

// CreateProvidersetupJSONRequestBody defines body for CreateProvidersetup for application/json ContentType.
type CreateProvidersetupJSONRequestBody CreateProviderSetupRequest

// SubmitProvidersetupStepJSONRequestBody defines body for SubmitProvidersetupStep for application/json ContentType.
type SubmitProvidersetupStepJSONRequestBody ProviderSetupStepCompleteRequest

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserRequest

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody UpdateUserJSONBody

// UserCreateRequestJSONRequestBody defines body for UserCreateRequest for application/json ContentType.
type UserCreateRequestJSONRequestBody CreateRequestRequest

// CallRequestOperationJSONRequestBody defines body for CallRequestOperation for application/json ContentType.
type CallRequestOperationJSONRequestBody OperationRequest

// ReviewRequestJSONRequestBody defines body for ReviewRequest for application/json ContentType.
type ReviewRequestJSONRequestBody ReviewRequest

// Getter for additional properties for AccessRuleTargetDetail_With. Returns the specified
// element and whether it was found
func (a AccessRuleTargetDetail_With) Get(fieldName string) (value AccessRuleTargetDetailArguments, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AccessRuleTargetDetail_With
func (a *AccessRuleTargetDetail_With) Set(fieldName string, value AccessRuleTargetDetailArguments) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]AccessRuleTargetDetailArguments)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AccessRuleTargetDetail_With to handle AdditionalProperties
func (a *AccessRuleTargetDetail_With) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]AccessRuleTargetDetailArguments)
		for fieldName, fieldBuf := range object {
			var fieldVal AccessRuleTargetDetailArguments
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AccessRuleTargetDetail_With to handle AdditionalProperties
func (a AccessRuleTargetDetail_With) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AccessRuleTargetDetailArguments_Groupings. Returns the specified
// element and whether it was found
func (a AccessRuleTargetDetailArguments_Groupings) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AccessRuleTargetDetailArguments_Groupings
func (a *AccessRuleTargetDetailArguments_Groupings) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a *AccessRuleTargetDetailArguments_Groupings) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a AccessRuleTargetDetailArguments_Groupings) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateAccessRuleTarget_With. Returns the specified
// element and whether it was found
func (a CreateAccessRuleTarget_With) Get(fieldName string) (value CreateAccessRuleTargetDetailArguments, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateAccessRuleTarget_With
func (a *CreateAccessRuleTarget_With) Set(fieldName string, value CreateAccessRuleTargetDetailArguments) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]CreateAccessRuleTargetDetailArguments)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateAccessRuleTarget_With to handle AdditionalProperties
func (a *CreateAccessRuleTarget_With) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]CreateAccessRuleTargetDetailArguments)
		for fieldName, fieldBuf := range object {
			var fieldVal CreateAccessRuleTargetDetailArguments
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateAccessRuleTarget_With to handle AdditionalProperties
func (a CreateAccessRuleTarget_With) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateAccessRuleTargetDetailArguments_Groupings. Returns the specified
// element and whether it was found
func (a CreateAccessRuleTargetDetailArguments_Groupings) Get(fieldName string) (value []string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateAccessRuleTargetDetailArguments_Groupings
func (a *CreateAccessRuleTargetDetailArguments_Groupings) Set(fieldName string, value []string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string][]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateAccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a *CreateAccessRuleTargetDetailArguments_Groupings) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string][]string)
		for fieldName, fieldBuf := range object {
			var fieldVal []string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateAccessRuleTargetDetailArguments_Groupings to handle AdditionalProperties
func (a CreateAccessRuleTargetDetailArguments_Groupings) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateRequestWith. Returns the specified
// element and whether it was found
func (a CreateRequestWith) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateRequestWith
func (a *CreateRequestWith) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateRequestWith to handle AdditionalProperties
func (a *CreateRequestWith) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateRequestWith to handle AdditionalProperties
func (a CreateRequestWith) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RequestAccessRuleTarget_Arguments. Returns the specified
// element and whether it was found
func (a RequestAccessRuleTarget_Arguments) Get(fieldName string) (value RequestArgument, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RequestAccessRuleTarget_Arguments
func (a *RequestAccessRuleTarget_Arguments) Set(fieldName string, value RequestArgument) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]RequestArgument)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RequestAccessRuleTarget_Arguments to handle AdditionalProperties
func (a *RequestAccessRuleTarget_Arguments) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]RequestArgument)
		for fieldName, fieldBuf := range object {
			var fieldVal RequestArgument
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RequestAccessRuleTarget_Arguments to handle AdditionalProperties
func (a RequestAccessRuleTarget_Arguments) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RequestDetail_Arguments. Returns the specified
// element and whether it was found
func (a RequestDetail_Arguments) Get(fieldName string) (value With, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RequestDetail_Arguments
func (a *RequestDetail_Arguments) Set(fieldName string, value With) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]With)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RequestDetail_Arguments to handle AdditionalProperties
func (a *RequestDetail_Arguments) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]With)
		for fieldName, fieldBuf := range object {
			var fieldVal With
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RequestDetail_Arguments to handle AdditionalProperties
func (a RequestDetail_Arguments) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List Access Rules
	// (GET /api/v1/access-rules)
	ListUserAccessRules(w http.ResponseWriter, r *http.Request)
	// Lookup an access rule based on the target
	// (GET /api/v1/access-rules/lookup)
	AccessRuleLookup(w http.ResponseWriter, r *http.Request, params AccessRuleLookupParams)
	// Get Access Rule
	// (GET /api/v1/access-rules/{ruleId})
	UserGetAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// List Access Rule approvers
	// (GET /api/v1/access-rules/{ruleId}/approvers)
	UserGetAccessRuleApprovers(w http.ResponseWriter, r *http.Request, ruleId string)
	// List Access Rules
	// (GET /api/v1/admin/access-rules)
	AdminListAccessRules(w http.ResponseWriter, r *http.Request, params AdminListAccessRulesParams)
	// Create Access Rule
	// (POST /api/v1/admin/access-rules)
	AdminCreateAccessRule(w http.ResponseWriter, r *http.Request)
	// Get Access Rule
	// (GET /api/v1/admin/access-rules/{ruleId})
	AdminGetAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Update Access Rule
	// (PUT /api/v1/admin/access-rules/{ruleId})
	AdminUpdateAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Archive Access Rule
	// (POST /api/v1/admin/access-rules/{ruleId}/archive)
	AdminArchiveAccessRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Get Access Rule version history
	// (GET /api/v1/admin/access-rules/{ruleId}/versions)
	AdminGetAccessRuleVersions(w http.ResponseWriter, r *http.Request, ruleId string)
	// Get Access Rule Version
	// (GET /api/v1/admin/access-rules/{ruleId}/versions/{version})
	AdminGetAccessRuleVersion(w http.ResponseWriter, r *http.Request, ruleId string, version string)
	// Get deployment version details
	// (GET /api/v1/admin/deployment/version)
	AdminGetDeploymentVersion(w http.ResponseWriter, r *http.Request)
	// List groups
	// (GET /api/v1/admin/groups)
	GetGroups(w http.ResponseWriter, r *http.Request, params GetGroupsParams)
	// Create Group
	// (POST /api/v1/admin/groups)
	CreateGroup(w http.ResponseWriter, r *http.Request)
	// Get Group Details
	// (GET /api/v1/admin/groups/{groupId})
	GetGroup(w http.ResponseWriter, r *http.Request, groupId string)
	// Get identity configuration
	// (GET /api/v1/admin/identity)
	IdentityConfiguration(w http.ResponseWriter, r *http.Request)
	// Sync Identity
	// (POST /api/v1/admin/identity/sync)
	IdentitySync(w http.ResponseWriter, r *http.Request)
	// List providers
	// (GET /api/v1/admin/providers)
	ListProviders(w http.ResponseWriter, r *http.Request)
	// List providers
	// (GET /api/v1/admin/providers/{providerId})
	GetProvider(w http.ResponseWriter, r *http.Request, providerId string)
	// Get provider arg schema
	// (GET /api/v1/admin/providers/{providerId}/args)
	GetProviderArgs(w http.ResponseWriter, r *http.Request, providerId string)
	// List provider arg options
	// (GET /api/v1/admin/providers/{providerId}/args/{argId}/options)
	ListProviderArgOptions(w http.ResponseWriter, r *http.Request, providerId string, argId string, params ListProviderArgOptionsParams)
	// List the provider setups in progress
	// (GET /api/v1/admin/providersetups)
	ListProvidersetups(w http.ResponseWriter, r *http.Request)
	// Begin the setup process for a new Access Provider
	// (POST /api/v1/admin/providersetups)
	CreateProvidersetup(w http.ResponseWriter, r *http.Request)
	// Delete an in-progress provider setup
	// (DELETE /api/v1/admin/providersetups/{providersetupId})
	DeleteProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Get an in-progress provider setup
	// (GET /api/v1/admin/providersetups/{providersetupId})
	GetProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Complete a ProviderSetup
	// (POST /api/v1/admin/providersetups/{providersetupId}/complete)
	CompleteProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Get the setup instructions for an Access Provider
	// (GET /api/v1/admin/providersetups/{providersetupId}/instructions)
	GetProvidersetupInstructions(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Update the completion status for a Provider setup step
	// (PUT /api/v1/admin/providersetups/{providersetupId}/steps/{stepIndex}/complete)
	SubmitProvidersetupStep(w http.ResponseWriter, r *http.Request, providersetupId string, stepIndex int)
	// Validate the configuration for a Provider Setup
	// (POST /api/v1/admin/providersetups/{providersetupId}/validate)
	ValidateProvidersetup(w http.ResponseWriter, r *http.Request, providersetupId string)
	// Your GET endpoint
	// (GET /api/v1/admin/requests)
	AdminListRequests(w http.ResponseWriter, r *http.Request, params AdminListRequestsParams)
	// Get a request
	// (GET /api/v1/admin/requests/{requestId})
	AdminGetRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// Returns a list of users
	// (GET /api/v1/admin/users)
	GetUsers(w http.ResponseWriter, r *http.Request, params GetUsersParams)
	// Create User
	// (POST /api/v1/admin/users)
	CreateUser(w http.ResponseWriter, r *http.Request)
	// Update User
	// (POST /api/v1/admin/users/{userId})
	UpdateUser(w http.ResponseWriter, r *http.Request, userId string)
	// List my requests
	// (GET /api/v1/requests)
	UserListRequests(w http.ResponseWriter, r *http.Request, params UserListRequestsParams)
	// Create a request
	// (POST /api/v1/requests)
	UserCreateRequest(w http.ResponseWriter, r *http.Request)
	// Your GET endpoint
	// (GET /api/v1/requests/past)
	UserListRequestsPast(w http.ResponseWriter, r *http.Request, params UserListRequestsPastParams)
	// Your GET endpoint
	// (GET /api/v1/requests/upcoming)
	UserListRequestsUpcoming(w http.ResponseWriter, r *http.Request, params UserListRequestsUpcomingParams)
	// Get a request
	// (GET /api/v1/requests/{requestId})
	UserGetRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// Get Access Instructions
	// (GET /api/v1/requests/{requestId}/access-instructions)
	GetAccessInstructions(w http.ResponseWriter, r *http.Request, requestId string)
	// Get Access Token
	// (GET /api/v1/requests/{requestId}/access-token)
	GetAccessToken(w http.ResponseWriter, r *http.Request, requestId string)
	// Cancel a request
	// (POST /api/v1/requests/{requestId}/cancel)
	CancelRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// List request events
	// (GET /api/v1/requests/{requestId}/events)
	ListRequestEvents(w http.ResponseWriter, r *http.Request, requestId string)
	// Call an RPC operation associated with an Access Request
	// (POST /api/v1/requests/{requestId}/operation)
	CallRequestOperation(w http.ResponseWriter, r *http.Request, requestId string)
	// Review a request
	// (POST /api/v1/requests/{requestId}/review)
	ReviewRequest(w http.ResponseWriter, r *http.Request, requestId string)
	// Revoke an active request
	// (POST /api/v1/requests/{requestid}/revoke)
	RevokeRequest(w http.ResponseWriter, r *http.Request, requestid string)
	// Get details for the current user
	// (GET /api/v1/users/me)
	GetMe(w http.ResponseWriter, r *http.Request)
	// Get a user
	// (GET /api/v1/users/{userId})
	GetUser(w http.ResponseWriter, r *http.Request, userId string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// ListUserAccessRules operation middleware
func (siw *ServerInterfaceWrapper) ListUserAccessRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserAccessRules(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AccessRuleLookup operation middleware
func (siw *ServerInterfaceWrapper) AccessRuleLookup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AccessRuleLookupParams

	// ------------- Optional query parameter "type" -------------
	if paramValue := r.URL.Query().Get("type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	// ------------- Optional query parameter "permissionSetArn.label" -------------
	if paramValue := r.URL.Query().Get("permissionSetArn.label"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "permissionSetArn.label", r.URL.Query(), &params.PermissionSetArnLabel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "permissionSetArn.label", Err: err})
		return
	}

	// ------------- Optional query parameter "accountId" -------------
	if paramValue := r.URL.Query().Get("accountId"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "accountId", r.URL.Query(), &params.AccountId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccessRuleLookup(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetAccessRule operation middleware
func (siw *ServerInterfaceWrapper) UserGetAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetAccessRuleApprovers operation middleware
func (siw *ServerInterfaceWrapper) UserGetAccessRuleApprovers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetAccessRuleApprovers(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminListAccessRules operation middleware
func (siw *ServerInterfaceWrapper) AdminListAccessRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminListAccessRulesParams

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminListAccessRules(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminCreateAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminCreateAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminCreateAccessRule(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminGetAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminUpdateAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminUpdateAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminUpdateAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminArchiveAccessRule operation middleware
func (siw *ServerInterfaceWrapper) AdminArchiveAccessRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminArchiveAccessRule(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetAccessRuleVersions operation middleware
func (siw *ServerInterfaceWrapper) AdminGetAccessRuleVersions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetAccessRuleVersions(w, r, ruleId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetAccessRuleVersion operation middleware
func (siw *ServerInterfaceWrapper) AdminGetAccessRuleVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameter("simple", false, "ruleId", chi.URLParam(r, "ruleId"), &ruleId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	// ------------- Path parameter "version" -------------
	var version string

	err = runtime.BindStyledParameter("simple", false, "version", chi.URLParam(r, "version"), &version)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "version", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetAccessRuleVersion(w, r, ruleId, version)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetDeploymentVersion operation middleware
func (siw *ServerInterfaceWrapper) AdminGetDeploymentVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetDeploymentVersion(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGroups operation middleware
func (siw *ServerInterfaceWrapper) GetGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGroupsParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroups(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateGroup operation middleware
func (siw *ServerInterfaceWrapper) CreateGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGroup(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGroup operation middleware
func (siw *ServerInterfaceWrapper) GetGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroup(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// IdentityConfiguration operation middleware
func (siw *ServerInterfaceWrapper) IdentityConfiguration(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.IdentityConfiguration(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// IdentitySync operation middleware
func (siw *ServerInterfaceWrapper) IdentitySync(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.IdentitySync(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListProviders operation middleware
func (siw *ServerInterfaceWrapper) ListProviders(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProviders(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProvider operation middleware
func (siw *ServerInterfaceWrapper) GetProvider(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providerId" -------------
	var providerId string

	err = runtime.BindStyledParameter("simple", false, "providerId", chi.URLParam(r, "providerId"), &providerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providerId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProvider(w, r, providerId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProviderArgs operation middleware
func (siw *ServerInterfaceWrapper) GetProviderArgs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providerId" -------------
	var providerId string

	err = runtime.BindStyledParameter("simple", false, "providerId", chi.URLParam(r, "providerId"), &providerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providerId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProviderArgs(w, r, providerId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListProviderArgOptions operation middleware
func (siw *ServerInterfaceWrapper) ListProviderArgOptions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providerId" -------------
	var providerId string

	err = runtime.BindStyledParameter("simple", false, "providerId", chi.URLParam(r, "providerId"), &providerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providerId", Err: err})
		return
	}

	// ------------- Path parameter "argId" -------------
	var argId string

	err = runtime.BindStyledParameter("simple", false, "argId", chi.URLParam(r, "argId"), &argId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "argId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProviderArgOptionsParams

	// ------------- Optional query parameter "refresh" -------------
	if paramValue := r.URL.Query().Get("refresh"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "refresh", r.URL.Query(), &params.Refresh)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "refresh", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProviderArgOptions(w, r, providerId, argId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListProvidersetups operation middleware
func (siw *ServerInterfaceWrapper) ListProvidersetups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProvidersetups(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) CreateProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProvidersetup(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) DeleteProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) GetProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CompleteProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) CompleteProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CompleteProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProvidersetupInstructions operation middleware
func (siw *ServerInterfaceWrapper) GetProvidersetupInstructions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProvidersetupInstructions(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SubmitProvidersetupStep operation middleware
func (siw *ServerInterfaceWrapper) SubmitProvidersetupStep(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	// ------------- Path parameter "stepIndex" -------------
	var stepIndex int

	err = runtime.BindStyledParameter("simple", false, "stepIndex", chi.URLParam(r, "stepIndex"), &stepIndex)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "stepIndex", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SubmitProvidersetupStep(w, r, providersetupId, stepIndex)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ValidateProvidersetup operation middleware
func (siw *ServerInterfaceWrapper) ValidateProvidersetup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "providersetupId" -------------
	var providersetupId string

	err = runtime.BindStyledParameter("simple", false, "providersetupId", chi.URLParam(r, "providersetupId"), &providersetupId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "providersetupId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ValidateProvidersetup(w, r, providersetupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminListRequests operation middleware
func (siw *ServerInterfaceWrapper) AdminListRequests(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AdminListRequestsParams

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminListRequests(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AdminGetRequest operation middleware
func (siw *ServerInterfaceWrapper) AdminGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AdminGetRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUsers operation middleware
func (siw *ServerInterfaceWrapper) GetUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUsers(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateUser operation middleware
func (siw *ServerInterfaceWrapper) CreateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUser(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateUser operation middleware
func (siw *ServerInterfaceWrapper) UpdateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserListRequests operation middleware
func (siw *ServerInterfaceWrapper) UserListRequests(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListRequestsParams

	// ------------- Optional query parameter "status" -------------
	if paramValue := r.URL.Query().Get("status"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	// ------------- Optional query parameter "reviewer" -------------
	if paramValue := r.URL.Query().Get("reviewer"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "reviewer", r.URL.Query(), &params.Reviewer)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "reviewer", Err: err})
		return
	}

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListRequests(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserCreateRequest operation middleware
func (siw *ServerInterfaceWrapper) UserCreateRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserCreateRequest(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserListRequestsPast operation middleware
func (siw *ServerInterfaceWrapper) UserListRequestsPast(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListRequestsPastParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListRequestsPast(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserListRequestsUpcoming operation middleware
func (siw *ServerInterfaceWrapper) UserListRequestsUpcoming(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListRequestsUpcomingParams

	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := r.URL.Query().Get("nextToken"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", r.URL.Query(), &params.NextToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nextToken", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserListRequestsUpcoming(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UserGetRequest operation middleware
func (siw *ServerInterfaceWrapper) UserGetRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UserGetRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetAccessInstructions operation middleware
func (siw *ServerInterfaceWrapper) GetAccessInstructions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAccessInstructions(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetAccessToken operation middleware
func (siw *ServerInterfaceWrapper) GetAccessToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAccessToken(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CancelRequest operation middleware
func (siw *ServerInterfaceWrapper) CancelRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CancelRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListRequestEvents operation middleware
func (siw *ServerInterfaceWrapper) ListRequestEvents(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRequestEvents(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CallRequestOperation operation middleware
func (siw *ServerInterfaceWrapper) CallRequestOperation(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CallRequestOperation(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ReviewRequest operation middleware
func (siw *ServerInterfaceWrapper) ReviewRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestId" -------------
	var requestId string

	err = runtime.BindStyledParameter("simple", false, "requestId", chi.URLParam(r, "requestId"), &requestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReviewRequest(w, r, requestId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RevokeRequest operation middleware
func (siw *ServerInterfaceWrapper) RevokeRequest(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "requestid" -------------
	var requestid string

	err = runtime.BindStyledParameter("simple", false, "requestid", chi.URLParam(r, "requestid"), &requestid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestid", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RevokeRequest(w, r, requestid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetMe operation middleware
func (siw *ServerInterfaceWrapper) GetMe(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMe(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUser operation middleware
func (siw *ServerInterfaceWrapper) GetUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules", wrapper.ListUserAccessRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules/lookup", wrapper.AccessRuleLookup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules/{ruleId}", wrapper.UserGetAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/access-rules/{ruleId}/approvers", wrapper.UserGetAccessRuleApprovers)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules", wrapper.AdminListAccessRules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/access-rules", wrapper.AdminCreateAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}", wrapper.AdminGetAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}", wrapper.AdminUpdateAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}/archive", wrapper.AdminArchiveAccessRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}/versions", wrapper.AdminGetAccessRuleVersions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/access-rules/{ruleId}/versions/{version}", wrapper.AdminGetAccessRuleVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/deployment/version", wrapper.AdminGetDeploymentVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/groups", wrapper.GetGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/groups", wrapper.CreateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/groups/{groupId}", wrapper.GetGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/identity", wrapper.IdentityConfiguration)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/identity/sync", wrapper.IdentitySync)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers", wrapper.ListProviders)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers/{providerId}", wrapper.GetProvider)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers/{providerId}/args", wrapper.GetProviderArgs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providers/{providerId}/args/{argId}/options", wrapper.ListProviderArgOptions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providersetups", wrapper.ListProvidersetups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/providersetups", wrapper.CreateProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}", wrapper.DeleteProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}", wrapper.GetProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/complete", wrapper.CompleteProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/instructions", wrapper.GetProvidersetupInstructions)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/steps/{stepIndex}/complete", wrapper.SubmitProvidersetupStep)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/providersetups/{providersetupId}/validate", wrapper.ValidateProvidersetup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/requests", wrapper.AdminListRequests)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/requests/{requestId}", wrapper.AdminGetRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/admin/users", wrapper.GetUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/users", wrapper.CreateUser)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/admin/users/{userId}", wrapper.UpdateUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests", wrapper.UserListRequests)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests", wrapper.UserCreateRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/past", wrapper.UserListRequestsPast)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/upcoming", wrapper.UserListRequestsUpcoming)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}", wrapper.UserGetRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}/access-instructions", wrapper.GetAccessInstructions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}/access-token", wrapper.GetAccessToken)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests/{requestId}/cancel", wrapper.CancelRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/requests/{requestId}/events", wrapper.ListRequestEvents)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests/{requestId}/operation", wrapper.CallRequestOperation)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests/{requestId}/review", wrapper.ReviewRequest)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/requests/{requestid}/revoke", wrapper.RevokeRequest)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/users/me", wrapper.GetMe)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/users/{userId}", wrapper.GetUser)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"yQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	pathPrefix := path.Dir(pathToFile)

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(pathPrefix, "./accesshandler/openapi.yml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
